{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as tf from '@tensorflow/tfjs-core';\nimport { backend_util, DataStorage, engine, env, kernel_impls, KernelBackend, max, slice_util, TensorBuffer, upcastType, util } from '@tensorflow/tfjs-core';\nconst nonMaxSuppressionV3Impl = kernel_impls.nonMaxSuppressionV3Impl;\nconst split = kernel_impls.split;\nconst tile = kernel_impls.tile;\nconst topkImpl = kernel_impls.topkImpl;\nconst whereImpl = kernel_impls.whereImpl;\nimport * as seedrandom from 'seedrandom';\nimport { assertNotComplex } from './cpu_util';\nexport class MathBackendCPU extends KernelBackend {\n  constructor() {\n    super();\n    this.blockSize = 48;\n    this.firstUse = true;\n    this.data = new DataStorage(this, engine());\n  }\n\n  write(values, shape, dtype) {\n    if (this.firstUse) {\n      this.firstUse = false;\n\n      if (env().get('IS_NODE')) {\n        backend_util.warn('\\n============================\\n' + 'Hi there ðŸ‘‹. Looks like you are running TensorFlow.js in ' + 'Node.js. To speed things up dramatically, install our node ' + 'backend, which binds to TensorFlow C++, by running ' + 'npm i @tensorflow/tfjs-node, ' + 'or npm i @tensorflow/tfjs-node-gpu if you have CUDA. ' + 'Then call require(\\'@tensorflow/tfjs-node\\'); (-gpu ' + 'suffix for CUDA) at the start of your program. ' + 'Visit https://github.com/tensorflow/tfjs-node for more details.' + '\\n============================');\n      }\n    }\n\n    const dataId = {};\n    this.data.set(dataId, {\n      values,\n      dtype,\n      refCount: 1\n    });\n    return dataId;\n  }\n  /**\n   * Create a data bucket in cpu backend.\n   * @param shape Shape of the `TensorInfo`.\n   * @param dtype DType of the `TensorInfo`.\n   * @param values The value of the `TensorInfo` stored as a flattened array.\n   */\n\n\n  makeTensorInfo(shape, dtype, values) {\n    let outId;\n\n    if (dtype === 'string' && values != null && values.length > 0 && util.isString(values[0])) {\n      const encodedValues = values.map(d => util.encodeString(d));\n      outId = this.write(encodedValues, shape, dtype);\n    } else {\n      outId = this.write(values, shape, dtype);\n    }\n\n    return {\n      dataId: outId,\n      shape,\n      dtype\n    };\n  }\n  /** Increase refCount of a `TensorData`. */\n\n\n  incRef(dataId) {\n    const tensorData = this.data.get(dataId);\n    tensorData.refCount++;\n  }\n  /** Decrease refCount of a `TensorData`. */\n\n\n  decRef(dataId) {\n    if (this.data.has(dataId)) {\n      const tensorData = this.data.get(dataId);\n      tensorData.refCount--;\n    }\n  }\n\n  move(dataId, values, shape, dtype) {\n    this.data.set(dataId, {\n      values,\n      dtype,\n      refCount: 1\n    });\n  }\n\n  numDataIds() {\n    return this.data.numDataIds();\n  }\n\n  async read(dataId) {\n    return this.readSync(dataId);\n  }\n\n  readSync(dataId) {\n    const {\n      dtype,\n      complexTensorInfos\n    } = this.data.get(dataId);\n\n    if (dtype === 'complex64') {\n      const realValues = this.readSync(complexTensorInfos.real.dataId);\n      const imagValues = this.readSync(complexTensorInfos.imag.dataId);\n      return backend_util.mergeRealAndImagArrays(realValues, imagValues);\n    }\n\n    return this.data.get(dataId).values;\n  }\n\n  bufferSync(t) {\n    const data = this.readSync(t.dataId);\n    let decodedData = data;\n\n    if (t.dtype === 'string') {\n      try {\n        // Decode the bytes into string.\n        decodedData = data.map(d => util.decodeString(d));\n      } catch (_a) {\n        throw new Error('Failed to decode encoded string bytes into utf-8');\n      }\n    }\n\n    return tf.buffer(t.shape, t.dtype, decodedData);\n  }\n\n  makeOutput(values, shape, dtype) {\n    const dataId = this.write(values, shape, dtype);\n    return engine().makeTensorFromDataId(dataId, shape, dtype, this);\n  }\n\n  disposeData(dataId) {\n    if (this.data.has(dataId)) {\n      const {\n        complexTensorInfos\n      } = this.data.get(dataId);\n\n      if (complexTensorInfos != null) {\n        this.disposeData(complexTensorInfos.real.dataId);\n        this.disposeData(complexTensorInfos.imag.dataId);\n      }\n\n      this.data.delete(dataId);\n    }\n  }\n\n  disposeIntermediateTensorInfo(tensorInfo) {\n    const dataId = tensorInfo.dataId;\n\n    if (this.data.has(dataId)) {\n      const tensorData = this.data.get(dataId);\n      tensorData.refCount--;\n\n      if (tensorData.refCount < 1) {\n        this.disposeData(dataId);\n      }\n    }\n  }\n\n  async time(f) {\n    const start = util.now();\n    f();\n    const kernelMs = util.now() - start;\n    return {\n      kernelMs\n    };\n  }\n\n  memory() {\n    return {\n      // Unreliable due to automatic gc. The numbers above are cumulative.\n      unreliable: true,\n      reasons: ['The reported memory is an upper bound. Due to automatic garbage ' + 'collection, the true allocated memory may be less.']\n    };\n  }\n\n  stridedSlice(x, begin, end, strides) {\n    assertNotComplex(x, 'stridedSlice');\n    const outShape = slice_util.computeOutShape(begin, end, strides);\n\n    if (outShape.some(axis => axis === 0)) {\n      return tf.tensor([], outShape);\n    }\n\n    const buffer = tf.buffer(outShape, x.dtype);\n    const xBuf = this.bufferSync(x);\n\n    for (let i = 0; i < buffer.size; i++) {\n      const loc = buffer.indexToLoc(i);\n      const newLoc = new Array(loc.length);\n\n      for (let j = 0; j < newLoc.length; j++) {\n        newLoc[j] = loc[j] * strides[j] + begin[j];\n      }\n\n      buffer.set(xBuf.get(...newLoc), ...loc);\n    }\n\n    return buffer.toTensor();\n  }\n\n  diag(x) {\n    const xVals = this.readSync(x.dataId);\n    const buffer = tf.buffer([x.size, x.size], x.dtype);\n    const vals = buffer.values;\n\n    for (let i = 0; i < xVals.length; i++) {\n      vals[i * x.size + i] = xVals[i];\n    }\n\n    return buffer.toTensor();\n  }\n\n  unstack(x, axis) {\n    const num = x.shape[axis];\n    const outShape = new Array(x.rank - 1);\n    let outIndex = 0;\n\n    for (let i = 0; i < x.rank; i++) {\n      if (i !== axis) {\n        outShape[outIndex++] = x.shape[i];\n      }\n    }\n\n    const begin = new Array(x.rank).fill(0);\n    const size = x.shape.slice();\n    size[axis] = 1;\n    const res = new Array(num);\n\n    for (let i = 0; i < res.length; i++) {\n      begin[axis] = i;\n      res[i] = tf.slice(x, begin, size).reshape(outShape);\n    }\n\n    return res;\n  }\n\n  reverse(x, axis) {\n    assertNotComplex(x, 'reverse');\n    const buffer = tf.buffer(x.shape, x.dtype);\n    const xBuf = this.bufferSync(x);\n\n    for (let i = 0; i < buffer.size; i++) {\n      const outLoc = buffer.indexToLoc(i);\n      const inLoc = outLoc.slice();\n      axis.forEach(ax => inLoc[ax] = x.shape[ax] - 1 - inLoc[ax]);\n      buffer.set(xBuf.get(...inLoc), ...outLoc);\n    }\n\n    return buffer.toTensor();\n  }\n\n  neg(x) {\n    assertNotComplex(x, 'neg'); // TODO(lina128): Use mul directly once neg is modularized.\n\n    return tf.mul(tf.scalar(-1), x);\n  }\n\n  addN(tensors) {\n    assertNotComplex(tensors, 'addN');\n    const vals = tensors.map(t => this.readSync(t.dataId));\n    const result = tf.buffer(tensors[0].shape, tensors[0].dtype);\n    const resultVals = result.values;\n\n    for (let i = 0; i < tensors.length; i++) {\n      const currVals = vals[i];\n\n      for (let j = 0; j < resultVals.length; j++) {\n        resultVals[j] += currVals[j];\n      }\n    }\n\n    return result.toTensor();\n  }\n\n  softmax(logits, dim) {\n    const axes = util.parseAxisParam([dim], logits.shape); // TODO(annxingyuan): Call maxImpl rather than op as part of softmax kernel\n    // modularization.\n\n    const maxLogit = max(logits, axes);\n    const expandedShape = backend_util.expandShapeToKeepDim(maxLogit.shape, axes); // TODO(lina128): Use sub directly once softmax is modularized.\n\n    const a = tf.sub(logits, maxLogit.reshape(expandedShape));\n    const b = tf.exp(a);\n    const sumExp = this.sum(b, axes).reshape(expandedShape); // TODO(annxingyuan): Call divImpl rather than op as part of softmax\n    // kernel modularization.\n\n    return tf.div(b, sumExp);\n  }\n\n  pow(a, b) {\n    assertNotComplex([a, b], 'pow');\n    return this.broadcastedBinaryOp(a, b, a.dtype, (aValue, bValue) => Math.pow(aValue, bValue));\n  }\n\n  floorDiv(a, b) {\n    assertNotComplex([a, b], 'floorDiv');\n\n    const op = (a, b) => Math.floor(a / b);\n\n    const outputDtype = 'int32';\n    return this.broadcastedBinaryOp(a, b, outputDtype, op);\n  }\n\n  sum(x, axes) {\n    assertNotComplex(x, 'sum');\n    backend_util.assertAxesAreInnerMostDims('sum', axes, x.rank);\n    const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(x.shape, axes);\n    const resultDtype = upcastType(x.dtype, 'int32');\n    const result = tf.zeros(outShape, resultDtype);\n    const reduceSize = util.sizeFromShape(reduceShape);\n    const vals = this.readSync(result.dataId);\n    const aVals = this.readSync(x.dataId);\n\n    for (let i = 0; i < vals.length; ++i) {\n      const offset = i * reduceSize;\n      let sum = 0;\n\n      for (let j = 0; j < reduceSize; ++j) {\n        sum += aVals[offset + j];\n      }\n\n      vals[i] = sum;\n    }\n\n    return result;\n  }\n\n  prod(x, axes) {\n    assertNotComplex(x, 'sum');\n    const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(x.shape, axes);\n    const resultDtype = upcastType(x.dtype, 'int32');\n    const result = tf.zeros(outShape, resultDtype);\n    const reduceSize = util.sizeFromShape(reduceShape);\n    const vals = this.readSync(result.dataId);\n    const aVals = this.readSync(x.dataId);\n\n    for (let i = 0; i < vals.length; ++i) {\n      const offset = i * reduceSize;\n      let prod = 1;\n\n      for (let j = 0; j < reduceSize; ++j) {\n        prod *= aVals[offset + j];\n      }\n\n      vals[i] = prod;\n    }\n\n    return result;\n  }\n\n  unsortedSegmentSum(x, segmentIds, numSegments) {\n    assertNotComplex(x, 'unsortedSegmentSum');\n    const res = []; // Reshape the segment id's so that they can be broadcast with\n    // x. The new shape should be [segmentIds.shape, 1, ..., 1]\n\n    const numIters = x.rank - segmentIds.rank;\n\n    for (let i = 0; i < numIters; ++i) {\n      segmentIds = segmentIds.expandDims(i + 1);\n    }\n\n    for (let i = 0; i < numSegments; ++i) {\n      const segmentId = tf.scalar(i, 'int32');\n      const mask = tf.equal(segmentId, segmentIds).asType('float32');\n      const sum = mask.mul(x).sum(0);\n      res.push(sum);\n    }\n\n    return tf.stack(res);\n  }\n\n  argMin(x, axis) {\n    assertNotComplex(x, 'argMin');\n    const axes = [axis];\n    backend_util.assertAxesAreInnerMostDims('argMin', axes, x.rank);\n    const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(x.shape, axes);\n    const result = tf.zeros(outShape, 'int32');\n    const reduceSize = util.sizeFromShape(reduceShape);\n    const vals = this.readSync(result.dataId);\n    const aVals = this.readSync(x.dataId);\n\n    for (let i = 0; i < vals.length; ++i) {\n      const offset = i * reduceSize;\n      let min = aVals[offset];\n      let minIndex = 0;\n\n      for (let j = 0; j < reduceSize; ++j) {\n        const value = aVals[offset + j];\n\n        if (value < min) {\n          min = value;\n          minIndex = j;\n        }\n      }\n\n      vals[i] = minIndex;\n    }\n\n    return result;\n  }\n\n  argMax(x, axis) {\n    assertNotComplex(x, 'argMax');\n    const axes = [axis];\n    backend_util.assertAxesAreInnerMostDims('argMax', axes, x.rank);\n    const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(x.shape, axes);\n    const result = tf.zeros(outShape, 'int32');\n    const reduceSize = util.sizeFromShape(reduceShape);\n    const vals = this.readSync(result.dataId);\n    const aVals = this.readSync(x.dataId);\n\n    for (let i = 0; i < vals.length; ++i) {\n      const offset = i * reduceSize;\n      let max = aVals[offset];\n      let maxIndex = 0;\n\n      for (let j = 0; j < reduceSize; ++j) {\n        const value = aVals[offset + j];\n\n        if (value > max) {\n          max = value;\n          maxIndex = j;\n        }\n      }\n\n      vals[i] = maxIndex;\n    }\n\n    return result;\n  }\n\n  cumsum(x, axis, exclusive, reverse) {\n    assertNotComplex(x, 'cumsum');\n\n    if (axis !== x.rank - 1) {\n      throw new Error(`backend.cumsum in CPU expects an inner-most axis=${x.rank - 1} ` + `but got axis=${axis}`);\n    }\n\n    const resultDtype = upcastType(x.dtype, 'int32');\n    const result = tf.zeros(x.shape, resultDtype);\n    const vals = this.readSync(result.dataId);\n    const aVals = this.readSync(x.dataId);\n    const finalDim = x.shape[x.rank - 1];\n    const indexAdjuster = reverse ? (i, j) => i + finalDim - j - 1 : (i, j) => i + j;\n\n    for (let i = 0; i < aVals.length; i += finalDim) {\n      for (let j = 0; j < finalDim; j++) {\n        const idx = indexAdjuster(i, j);\n\n        if (j === 0) {\n          vals[idx] = exclusive ? 0 : aVals[idx];\n        } else {\n          const prevIdx = indexAdjuster(i, j - 1);\n          vals[idx] = exclusive ? aVals[prevIdx] + vals[prevIdx] : aVals[idx] + vals[prevIdx];\n        }\n      }\n    }\n\n    return result;\n  }\n\n  equal(a, b) {\n    assertNotComplex([a, b], 'equal');\n    return this.broadcastedBinaryOp(a, b, 'bool', (aVal, bVal) => {\n      return aVal === bVal ? 1 : 0;\n    });\n  }\n\n  notEqual(a, b) {\n    assertNotComplex([a, b], 'notEqual');\n    return this.broadcastedBinaryOp(a, b, 'bool', (aVal, bVal) => {\n      return aVal !== bVal ? 1 : 0;\n    });\n  }\n\n  less(a, b) {\n    assertNotComplex([a, b], 'less');\n    return this.broadcastedBinaryOp(a, b, 'bool', (aVal, bVal) => {\n      return aVal < bVal ? 1 : 0;\n    });\n  }\n\n  lessEqual(a, b) {\n    assertNotComplex([a, b], 'lessEqual');\n    return this.broadcastedBinaryOp(a, b, 'bool', (aVal, bVal) => {\n      return aVal <= bVal ? 1 : 0;\n    });\n  }\n\n  greater(a, b) {\n    assertNotComplex([a, b], 'greater');\n    return this.broadcastedBinaryOp(a, b, 'bool', (aVal, bVal) => {\n      return aVal > bVal ? 1 : 0;\n    });\n  }\n\n  greaterEqual(a, b) {\n    assertNotComplex([a, b], 'greaterEqual');\n    return this.broadcastedBinaryOp(a, b, 'bool', (aVal, bVal) => {\n      return aVal >= bVal ? 1 : 0;\n    });\n  }\n\n  logicalAnd(a, b) {\n    assertNotComplex([a, b], 'logicalAnd');\n    return this.broadcastedBinaryOp(a, b, 'bool', (aVal, bVal) => {\n      return aVal && bVal;\n    });\n  }\n\n  logicalOr(a, b) {\n    assertNotComplex([a, b], 'logicalOr');\n    return this.broadcastedBinaryOp(a, b, 'bool', (aVal, bVal) => {\n      return aVal || bVal;\n    });\n  }\n\n  select(condition, a, b) {\n    assertNotComplex([condition, a, b], 'select');\n    const values = this.readSync(condition.dataId);\n    const aValues = this.readSync(a.dataId);\n    const bValues = this.readSync(b.dataId);\n    const result = tf.zeros(a.shape, upcastType(a.dtype, b.dtype));\n    const newValues = this.readSync(result.dataId);\n    let index = 0;\n    const offset = condition.rank === 0 || condition.rank > 1 || a.rank === 1 ? 1 : util.sizeFromShape(a.shape.slice(1));\n\n    for (let i = 0; i < values.length; i++) {\n      for (let j = 0; j < offset; j++) {\n        if (values[i] === 1) {\n          newValues[index++] = aValues[i];\n        } else {\n          newValues[index++] = bValues[i];\n        }\n      }\n    }\n\n    return result;\n  }\n\n  where(condition) {\n    assertNotComplex([condition], 'where');\n    const condVals = this.readSync(condition.dataId);\n    return whereImpl(condition.shape, condVals);\n  }\n\n  topk(x, k, sorted) {\n    assertNotComplex(x, 'topk');\n    const xVals = this.readSync(x.dataId);\n    return topkImpl(xVals, x.shape, x.dtype, k, sorted);\n  }\n\n  min(x, axes) {\n    assertNotComplex(x, 'min');\n    backend_util.assertAxesAreInnerMostDims('min', axes, x.rank);\n    const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(x.shape, axes);\n    const result = tf.zeros(outShape, x.dtype);\n    const reduceSize = util.sizeFromShape(reduceShape);\n    const vals = this.readSync(result.dataId);\n    const aVals = this.readSync(x.dataId);\n\n    for (let i = 0; i < vals.length; ++i) {\n      const offset = i * reduceSize;\n      let min = aVals[offset];\n\n      for (let j = 0; j < reduceSize; ++j) {\n        const value = aVals[offset + j];\n\n        if (value < min) {\n          min = value;\n        }\n      }\n\n      vals[i] = min;\n    }\n\n    return result;\n  }\n\n  minimum(a, b) {\n    assertNotComplex([a, b], 'minimum');\n    return this.broadcastedBinaryOp(a, b, a.dtype, (aVal, bVal) => Math.min(aVal, bVal));\n  }\n\n  mod(a, b) {\n    assertNotComplex([a, b], 'mod');\n    return this.broadcastedBinaryOp(a, b, a.dtype, (aVal, bVal) => {\n      const rem = aVal % bVal;\n\n      if (aVal < 0 && bVal < 0 || aVal >= 0 && bVal >= 0) {\n        return rem;\n      } else {\n        return (rem + bVal) % bVal;\n      }\n    });\n  }\n\n  maximum(a, b) {\n    assertNotComplex([a, b], 'maximum');\n    return this.broadcastedBinaryOp(a, b, a.dtype, (aVal, bVal) => Math.max(aVal, bVal));\n  }\n\n  all(x, axes) {\n    assertNotComplex(x, 'all');\n    backend_util.assertAxesAreInnerMostDims('all', axes, x.rank);\n    const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(x.shape, axes);\n    const result = tf.zeros(outShape, x.dtype);\n    const reduceSize = util.sizeFromShape(reduceShape);\n    const vals = this.readSync(result.dataId);\n    const aVals = this.readSync(x.dataId);\n\n    for (let i = 0; i < vals.length; ++i) {\n      const offset = i * reduceSize;\n      let all = aVals[offset];\n\n      for (let j = 0; j < reduceSize; ++j) {\n        const value = aVals[offset + j];\n        all = all && value;\n      }\n\n      vals[i] = all;\n    }\n\n    return result;\n  }\n\n  any(x, axes) {\n    assertNotComplex(x, 'any');\n    backend_util.assertAxesAreInnerMostDims('any', axes, x.rank);\n    const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(x.shape, axes);\n    const result = tf.zeros(outShape, x.dtype);\n    const reduceSize = util.sizeFromShape(reduceShape);\n    const vals = this.readSync(result.dataId);\n    const aVals = this.readSync(x.dataId);\n\n    for (let i = 0; i < vals.length; ++i) {\n      const offset = i * reduceSize;\n      let anyVal = aVals[offset];\n\n      for (let j = 0; j < reduceSize; ++j) {\n        const value = aVals[offset + j];\n        anyVal = anyVal || value;\n      }\n\n      vals[i] = anyVal;\n    }\n\n    return result;\n  }\n\n  squaredDifference(a, b) {\n    assertNotComplex([a, b], 'squaredDifference');\n    return this.broadcastedBinaryOp(a, b, a.dtype, (aVal, bVal) => {\n      const diff = aVal - bVal;\n      return diff * diff;\n    });\n  }\n\n  eluDer(dy, y) {\n    assertNotComplex([dy, y], 'eluDer');\n    const resultValues = new Float32Array(y.size);\n    const values = this.readSync(y.dataId);\n    const dyValues = this.readSync(dy.dataId);\n\n    for (let i = 0; i < values.length; ++i) {\n      const v = values[i];\n\n      if (v >= 1) {\n        resultValues[i] = dyValues[i];\n      } else {\n        resultValues[i] = dyValues[i] * (v + 1);\n      }\n    }\n\n    return this.makeOutput(resultValues, y.shape, 'float32');\n  }\n\n  atan2(a, b) {\n    assertNotComplex([a, b], 'atan2');\n    return this.broadcastedBinaryOp(a, b, a.dtype, (aValue, bValue) => Math.atan2(aValue, bValue));\n  }\n\n  tile(x, reps) {\n    assertNotComplex(x, 'tile');\n    return tile(this.bufferSync(x), reps);\n  }\n\n  gather(x, indices, axis) {\n    assertNotComplex([x, indices], 'gather');\n    const newShape = x.shape.slice();\n    const indicesValues = this.readSync(indices.dataId);\n    newShape[axis] = indicesValues.length;\n    const result = tf.buffer(newShape, x.dtype);\n    const xBuf = this.bufferSync(x);\n\n    for (let i = 0; i < result.size; ++i) {\n      const newLoc = result.indexToLoc(i);\n      const originalLoc = newLoc.slice();\n      originalLoc[axis] = indicesValues[newLoc[axis]];\n      const originalIndex = xBuf.locToIndex(originalLoc);\n      result.values[i] = xBuf.values[originalIndex];\n    }\n\n    return result.toTensor();\n  }\n\n  batchToSpaceND(x, blockShape, crops) {\n    assertNotComplex([x], 'batchToSpaceND');\n    const prod = blockShape.reduce((a, b) => a * b);\n    const reshaped = backend_util.getReshaped(x.shape, blockShape, prod);\n    const permuted = backend_util.getPermuted(reshaped.length, blockShape.length);\n    const reshapedPermuted = backend_util.getReshapedPermuted(x.shape, blockShape, prod);\n    const sliceBeginCoords = backend_util.getSliceBeginCoords(crops, blockShape.length);\n    const sliceSize = backend_util.getSliceSize(reshapedPermuted, crops, blockShape.length);\n    return tf.transpose(x.reshape(reshaped), permuted).reshape(reshapedPermuted).slice(sliceBeginCoords, sliceSize);\n  }\n\n  pool3d(x, convInfo, poolType) {\n    assertNotComplex(x, 'pool3d');\n    const strideDepth = convInfo.strideDepth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationDepth = convInfo.dilationDepth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n    const padFront = convInfo.padInfo.front;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const initialValue = poolType === 'max' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n    const xValues = this.readSync(x.dataId);\n    const output = tf.buffer(convInfo.outShape, x.dtype);\n    const outputVals = output.values;\n    const outputBatchStrides = convInfo.outShape[1] * convInfo.outShape[2] * convInfo.outShape[3] * convInfo.outShape[4];\n    const outputDepthStrides = convInfo.outShape[2] * convInfo.outShape[3] * convInfo.outShape[4];\n    const outputRowStrides = convInfo.outShape[3] * convInfo.outShape[4];\n    const outputColStrides = convInfo.outShape[4];\n\n    for (let batch = 0; batch < convInfo.batchSize; ++batch) {\n      const outputBatchOffset = batch * outputBatchStrides;\n      const inputBatchOffset = batch * x.strides[0];\n\n      for (let channel = 0; channel < convInfo.inChannels; ++channel) {\n        for (let yDepth = 0; yDepth < convInfo.outDepth; ++yDepth) {\n          const xDepthCorner = yDepth * strideDepth - padFront;\n          let xDepthMin = xDepthCorner;\n\n          while (xDepthMin < 0) {\n            xDepthMin += dilationDepth;\n          }\n\n          const xDepthMax = Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);\n          const outputDepthOffset = outputBatchOffset + yDepth * outputDepthStrides;\n\n          for (let yRow = 0; yRow < convInfo.outHeight; ++yRow) {\n            const xRowCorner = yRow * strideHeight - padTop;\n            let xRowMin = xRowCorner;\n\n            while (xRowMin < 0) {\n              xRowMin += dilationHeight;\n            }\n\n            const xRowMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);\n            const outputRowOffset = outputDepthOffset + yRow * outputRowStrides;\n\n            for (let yCol = 0; yCol < convInfo.outWidth; ++yCol) {\n              const xColCorner = yCol * strideWidth - padLeft;\n              let xColMin = xColCorner;\n\n              while (xColMin < 0) {\n                xColMin += dilationWidth;\n              }\n\n              const xColMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner); // Shader code begins\n\n              const outputColOffset = outputRowOffset + yCol * outputColStrides;\n              let minMaxValue = initialValue;\n              let avgValue = 0;\n              let count = 0;\n\n              for (let xDepth = xDepthMin; xDepth < xDepthMax; xDepth += dilationDepth) {\n                const xDepthOffset = inputBatchOffset + xDepth * x.strides[1];\n\n                for (let xRow = xRowMin; xRow < xRowMax; xRow += dilationHeight) {\n                  const xRowOffset = xDepthOffset + xRow * x.strides[2];\n\n                  for (let xCol = xColMin; xCol < xColMax; xCol += dilationWidth) {\n                    const xColOffset = xRowOffset + xCol * x.strides[3];\n                    const pixel = xValues[xColOffset + channel];\n\n                    if (poolType === 'max' && pixel > minMaxValue) {\n                      minMaxValue = pixel;\n                    } else if (poolType === 'avg') {\n                      avgValue += pixel;\n                      count++;\n                    }\n\n                    if (isNaN(minMaxValue)) {\n                      break;\n                    }\n                  }\n\n                  if (isNaN(minMaxValue)) {\n                    break;\n                  }\n                }\n\n                if (isNaN(minMaxValue)) {\n                  break;\n                }\n              }\n\n              const outputOffset = outputColOffset + channel;\n              outputVals[outputOffset] = poolType === 'avg' ? avgValue / count : minMaxValue;\n            }\n          }\n        }\n      }\n    }\n\n    return output.toTensor();\n  }\n\n  avgPool3d(x, convInfo) {\n    assertNotComplex(x, 'avgPool3d');\n    return this.pool3d(x, convInfo, 'avg').toFloat();\n  }\n\n  avgPool3dBackprop(dy, x, convInfo) {\n    assertNotComplex([dy, x], 'avgPool3dBackprop');\n    const strideDepth = convInfo.strideDepth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const filterDepth = convInfo.filterDepth;\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n    const dilationDepth = convInfo.dilationDepth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n    const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;\n    const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n    const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n    const dx = tf.buffer(x.shape, 'float32');\n    const avgMultiplier = 1 / (filterDepth * filterHeight * filterWidth);\n    const dyBuf = this.bufferSync(dy);\n\n    for (let batch = 0; batch < convInfo.batchSize; ++batch) {\n      for (let channel = 0; channel < convInfo.inChannels; ++channel) {\n        for (let dxDepth = 0; dxDepth < convInfo.inDepth; ++dxDepth) {\n          for (let dxRow = 0; dxRow < convInfo.inHeight; ++dxRow) {\n            for (let dxCol = 0; dxCol < convInfo.inWidth; ++dxCol) {\n              // Shader code begins.\n              const dyDepthCorner = dxDepth - padFront;\n              const dyRowCorner = dxRow - padTop;\n              const dyColCorner = dxCol - padLeft;\n              let dotProd = 0;\n\n              for (let wDepth = 0; wDepth < effectiveFilterDepth; wDepth += dilationDepth) {\n                const dyDepth = (dyDepthCorner + wDepth) / strideDepth;\n\n                if (dyDepth < 0 || dyDepth >= convInfo.outDepth || Math.floor(dyDepth) !== dyDepth) {\n                  continue;\n                }\n\n                for (let wRow = 0; wRow < effectiveFilterHeight; wRow += dilationHeight) {\n                  const dyRow = (dyRowCorner + wRow) / strideHeight;\n\n                  if (dyRow < 0 || dyRow >= convInfo.outHeight || Math.floor(dyRow) !== dyRow) {\n                    continue;\n                  }\n\n                  for (let wCol = 0; wCol < effectiveFilterWidth; wCol += dilationWidth) {\n                    const dyCol = (dyColCorner + wCol) / strideWidth;\n\n                    if (dyCol < 0 || dyCol >= convInfo.outWidth || Math.floor(dyCol) !== dyCol) {\n                      continue;\n                    }\n\n                    const pixel = dyBuf.get(batch, dyDepth, dyRow, dyCol, channel);\n                    dotProd += pixel;\n                  }\n                }\n              }\n\n              dx.set(dotProd * avgMultiplier, batch, dxDepth, dxRow, dxCol, channel);\n            }\n          }\n        }\n      }\n    }\n\n    return dx.toTensor();\n  }\n\n  maxPool3d(x, convInfo) {\n    assertNotComplex(x, 'maxPool3d');\n    return this.pool3d(x, convInfo, 'max').toFloat();\n  }\n\n  maxPool3dPositions(x, convInfo) {\n    const maxPositions = tf.buffer(convInfo.outShape, 'int32');\n    const strideDepth = convInfo.strideDepth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationDepth = convInfo.dilationDepth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n    const padFront = convInfo.padInfo.front;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const xBuf = this.bufferSync(x);\n\n    for (let batch = 0; batch < convInfo.batchSize; ++batch) {\n      for (let channel = 0; channel < convInfo.inChannels; ++channel) {\n        for (let yDepth = 0; yDepth < convInfo.outDepth; ++yDepth) {\n          const xDepthCorner = yDepth * strideDepth - padFront;\n          let xDepthMin = xDepthCorner;\n\n          while (xDepthMin < 0) {\n            xDepthMin += dilationDepth;\n          }\n\n          const xDepthMax = Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);\n\n          for (let yRow = 0; yRow < convInfo.outHeight; ++yRow) {\n            const xRowCorner = yRow * strideHeight - padTop;\n            let xRowMin = xRowCorner;\n\n            while (xRowMin < 0) {\n              xRowMin += dilationHeight;\n            }\n\n            const xRowMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);\n\n            for (let yCol = 0; yCol < convInfo.outWidth; ++yCol) {\n              const xColCorner = yCol * strideWidth - padLeft;\n              let xColMin = xColCorner;\n\n              while (xColMin < 0) {\n                xColMin += dilationWidth;\n              }\n\n              const xColMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner); // Shader code begins\n\n              let maxValue = Number.NEGATIVE_INFINITY;\n              let maxPosition = -1;\n\n              for (let xDepth = xDepthMin; xDepth < xDepthMax; xDepth += dilationDepth) {\n                const wDepth = xDepth - xDepthCorner;\n\n                for (let xRow = xRowMin; xRow < xRowMax; xRow += dilationHeight) {\n                  const wRow = xRow - xRowCorner;\n\n                  for (let xCol = xColMin; xCol < xColMax; xCol += dilationWidth) {\n                    const wCol = xCol - xColCorner;\n                    const pixel = xBuf.get(batch, xDepth, xRow, xCol, channel);\n\n                    if (pixel >= maxValue) {\n                      maxValue = pixel;\n                      maxPosition = wDepth * effectiveFilterHeight * effectiveFilterWidth + wRow * effectiveFilterHeight + wCol;\n                    }\n                  }\n                }\n              }\n\n              maxPositions.set(maxPosition, batch, yDepth, yRow, yCol, channel);\n            }\n          }\n        }\n      }\n    }\n\n    return maxPositions.toTensor();\n  }\n\n  maxPool3dBackprop(dy, x, y, convInfo) {\n    assertNotComplex([x, y], 'maxPool3dBackprop');\n    const maxPositions = this.maxPool3dPositions(x, convInfo);\n    const strideDepth = convInfo.strideDepth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationDepth = convInfo.dilationDepth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n    const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;\n    const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n    const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n    const dx = tf.buffer(x.shape, 'float32');\n    const maxPosBuf = this.bufferSync(maxPositions);\n    const dyBuf = this.bufferSync(dy);\n\n    for (let batch = 0; batch < convInfo.batchSize; ++batch) {\n      for (let channel = 0; channel < convInfo.inChannels; ++channel) {\n        for (let dxDepth = 0; dxDepth < convInfo.inDepth; ++dxDepth) {\n          for (let dxRow = 0; dxRow < convInfo.inHeight; ++dxRow) {\n            for (let dxCol = 0; dxCol < convInfo.inWidth; ++dxCol) {\n              // Shader code begins\n              const dyDepthCorner = dxDepth - padFront;\n              const dyRowCorner = dxRow - padTop;\n              const dyColCorner = dxCol - padLeft;\n              let dotProd = 0;\n\n              for (let wDepth = 0; wDepth < effectiveFilterDepth; wDepth += dilationDepth) {\n                const dyDepth = (dyDepthCorner + wDepth) / strideDepth;\n\n                if (dyDepth < 0 || dyDepth >= convInfo.outDepth || Math.floor(dyDepth) !== dyDepth) {\n                  continue;\n                }\n\n                for (let wRow = 0; wRow < effectiveFilterHeight; wRow += dilationHeight) {\n                  const dyRow = (dyRowCorner + wRow) / strideHeight;\n\n                  if (dyRow < 0 || dyRow >= convInfo.outHeight || Math.floor(dyRow) !== dyRow) {\n                    continue;\n                  }\n\n                  for (let wCol = 0; wCol < effectiveFilterWidth; wCol += dilationWidth) {\n                    const dyCol = (dyColCorner + wCol) / strideWidth;\n\n                    if (dyCol < 0 || dyCol >= convInfo.outWidth || Math.floor(dyCol) !== dyCol) {\n                      continue;\n                    }\n\n                    const maxPos = effectiveFilterDepth * effectiveFilterHeight * effectiveFilterWidth - 1 - maxPosBuf.get(batch, dyDepth, dyRow, dyCol, channel);\n                    const curPos = wDepth * effectiveFilterHeight * effectiveFilterWidth + wRow * effectiveFilterWidth + wCol;\n                    const mask = maxPos === curPos ? 1 : 0;\n\n                    if (mask === 0) {\n                      continue;\n                    }\n\n                    const pixel = dyBuf.get(batch, dyDepth, dyRow, dyCol, channel);\n                    dotProd += pixel * mask;\n                  }\n                }\n              }\n\n              dx.set(dotProd, batch, dxDepth, dxRow, dxCol, channel);\n            }\n          }\n        }\n      }\n    }\n\n    return dx.toTensor();\n  }\n\n  resizeBilinear(x, newHeight, newWidth, alignCorners) {\n    assertNotComplex(x, 'resizeBilinear');\n    const [batch, oldHeight, oldWidth, numChannels] = x.shape;\n    const xValues = this.readSync(x.dataId);\n    const result = new Float32Array(util.sizeFromShape([batch, newHeight, newWidth, numChannels]));\n    const effectiveInputSize = [alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight, alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth];\n    const effectiveOutputSize = [alignCorners && newHeight > 1 ? newHeight - 1 : newHeight, alignCorners && newWidth > 1 ? newWidth - 1 : newWidth];\n    let outputIdx = 0;\n    const effectiveRowSizeRatio = effectiveInputSize[0] / effectiveOutputSize[0];\n    const effectiveColSizeRatio = effectiveInputSize[1] / effectiveOutputSize[1];\n\n    for (let b = 0; b < batch; b++) {\n      for (let r = 0; r < newHeight; r++) {\n        const sourceFracRow = effectiveRowSizeRatio * r;\n        const sourceRowFloor = Math.floor(sourceFracRow);\n        const rowFrac = sourceFracRow - sourceRowFloor;\n        const sourceRowCeil = Math.min(oldHeight - 1, Math.ceil(sourceFracRow));\n        const topRowOffset = b * x.strides[0] + sourceRowFloor * x.strides[1];\n        const botRowOffset = b * x.strides[0] + sourceRowCeil * x.strides[1];\n\n        for (let c = 0; c < newWidth; c++) {\n          const sourceFracCol = effectiveColSizeRatio * c;\n          const sourceColFloor = Math.floor(sourceFracCol);\n          const colFrac = sourceFracCol - sourceColFloor;\n          const sourceColCeil = Math.min(oldWidth - 1, Math.ceil(sourceFracCol));\n          const topLeftOffest = topRowOffset + sourceColFloor * x.strides[2];\n          const botLeftOffset = botRowOffset + sourceColFloor * x.strides[2];\n          const topRightOffset = topRowOffset + sourceColCeil * x.strides[2];\n          const botRightOffest = botRowOffset + sourceColCeil * x.strides[2];\n\n          for (let d = 0; d < numChannels; d++) {\n            // Begin shader.\n            // Compute the fractional index of the source.\n            const topLeft = xValues[topLeftOffest + d];\n            const bottomLeft = xValues[botLeftOffset + d];\n            const topRight = xValues[topRightOffset + d];\n            const bottomRight = xValues[botRightOffest + d];\n            const top = topLeft + (topRight - topLeft) * colFrac;\n            const bottom = bottomLeft + (bottomRight - bottomLeft) * colFrac;\n            const newValue = top + (bottom - top) * rowFrac;\n            result[outputIdx++] = newValue;\n          }\n        }\n      }\n    }\n\n    return tf.tensor(result, [batch, newHeight, newWidth, numChannels]);\n  }\n\n  resizeBilinearBackprop(dy, x, alignCorners) {\n    assertNotComplex([dy, x], 'resizeBilinearBackprop');\n    const [batch, xHeight, xWidth, depth] = x.shape;\n    const [, yHeight, yWidth] = dy.shape;\n    const output = new Float32Array(batch * xHeight * xWidth * depth); // In the backwards pass, we want to find the pixels that were generated\n    // for each pixel in the input image the forward pass and add the\n    // corresponding coefficient from dy to the gradient (with some\n    // interpolation).\n\n    const effectiveXSize = [alignCorners && yHeight > 1 ? xHeight - 1 : xHeight, alignCorners && yWidth > 1 ? xWidth - 1 : xWidth];\n    const effectiveYSize = [alignCorners && yHeight > 1 ? yHeight - 1 : yHeight, alignCorners && yWidth > 1 ? yWidth - 1 : yWidth];\n    const heightScale = effectiveXSize[0] / effectiveYSize[0];\n    const widthScale = effectiveXSize[1] / effectiveYSize[1]; // Reference implementation\n    // tslint:disable-next-line:max-line-length\n    // https://github.com/tensorflow/tensorflow/blob/3039375c86a5bbc9610c7725dcaa95d635f87ba2/tensorflow/core/kernels/resize_bilinear_op.cc#L275\n\n    const dyValues = this.readSync(dy.dataId);\n    let offset = 0;\n\n    for (let b = 0; b < batch; b++) {\n      const bOffset = b * x.strides[0];\n\n      for (let r = 0; r < yHeight; r++) {\n        const dxR = r * heightScale;\n        const topDxRIndex = Math.floor(dxR);\n        const bottomDxRIndex = Math.min(Math.ceil(dxR), xHeight - 1);\n        const topDxROffset = bOffset + topDxRIndex * x.strides[1];\n        const bottomDxROffset = bOffset + bottomDxRIndex * x.strides[1];\n        const dxRLerp = dxR - topDxRIndex;\n        const inverseDxRLerp = 1.0 - dxRLerp;\n\n        for (let c = 0; c < yWidth; c++) {\n          const dxC = c * widthScale;\n          const leftDxCIndex = Math.floor(dxC);\n          const rightDxCIndex = Math.min(Math.ceil(dxC), xWidth - 1);\n          const dxCLerp = dxC - leftDxCIndex;\n          const inverseDxCLerp = 1.0 - dxCLerp;\n          const topLeftRCOffset = topDxROffset + leftDxCIndex * x.strides[2];\n          const topRightRCOffset = topDxROffset + rightDxCIndex * x.strides[2];\n          const bottomLeftRCOffset = bottomDxROffset + leftDxCIndex * x.strides[2];\n          const bottomRightRCOffset = bottomDxROffset + rightDxCIndex * x.strides[2];\n          const inverseDxRLerpTimesInverseDxCLerp = inverseDxRLerp * inverseDxCLerp;\n          const inverseDxRLerpTimesDxCLerp = inverseDxRLerp * dxCLerp;\n          const dxRLerpTimesInverseDxCLerp = dxRLerp * inverseDxCLerp;\n          const dxRLerpTimesDxCLerp = dxRLerp * dxCLerp;\n\n          for (let d = 0; d < depth; d++) {\n            const dyVal = dyValues[offset++];\n            output[topLeftRCOffset + d] += dyVal * inverseDxRLerpTimesInverseDxCLerp;\n            output[topRightRCOffset + d] += dyVal * inverseDxRLerpTimesDxCLerp;\n            output[bottomLeftRCOffset + d] += dyVal * dxRLerpTimesInverseDxCLerp;\n            output[bottomRightRCOffset + d] += dyVal * dxRLerpTimesDxCLerp;\n          }\n        }\n      }\n    }\n\n    return tf.tensor4d(output, [batch, xWidth, xHeight, depth], x.dtype);\n  }\n\n  resizeNearestNeighbor(x, newHeight, newWidth, alignCorners) {\n    assertNotComplex(x, 'resizeNearestNeighbor');\n    const [batch, oldHeight, oldWidth, numChannels] = x.shape;\n    const xValues = this.readSync(x.dataId);\n    const output = new Float32Array(batch * newHeight * newWidth * numChannels);\n    const effectiveInputSize = [alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight, alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth];\n    const effectiveOutputSize = [alignCorners && newHeight > 1 ? newHeight - 1 : newHeight, alignCorners && newWidth > 1 ? newWidth - 1 : newWidth];\n    const effectiveRowSizeRatio = effectiveInputSize[0] / effectiveOutputSize[0];\n    const effectiveColSizeRatio = effectiveInputSize[1] / effectiveOutputSize[1];\n    let outputOffset = 0;\n\n    for (let b = 0; b < batch; b++) {\n      const batchOffset = b * x.strides[0];\n\n      for (let r = 0; r < newHeight; r++) {\n        const sourceFracRow = effectiveRowSizeRatio * r;\n        const sourceNearestRow = Math.min(oldHeight - 1, alignCorners ? Math.round(sourceFracRow) : Math.floor(sourceFracRow));\n        const rowOffset = batchOffset + sourceNearestRow * x.strides[1];\n\n        for (let c = 0; c < newWidth; c++) {\n          const sourceFracCol = effectiveColSizeRatio * c;\n          const sourceNearestCol = Math.min(oldWidth - 1, alignCorners ? Math.round(sourceFracCol) : Math.floor(sourceFracCol));\n          const colOffset = rowOffset + sourceNearestCol * x.strides[2];\n\n          for (let d = 0; d < numChannels; d++) {\n            // Begin shader.\n            // Compute the fractional index of the source.\n            const newVal = xValues[colOffset + d];\n            output[outputOffset++] = newVal;\n          }\n        }\n      }\n    }\n\n    return tf.tensor(output, [batch, newHeight, newWidth, numChannels], x.dtype);\n  }\n\n  resizeNearestNeighborBackprop(dy, x, alignCorners) {\n    assertNotComplex([dy, x], 'resizeNearestNeighborBackprop');\n    const [batch, xHeight, xWidth, depth] = x.shape;\n    const [, yHeight, yWidth] = dy.shape;\n    const output = new Float32Array(batch * xHeight * xWidth * depth);\n    const dyValues = this.readSync(dy.dataId); // In the backwards pass, we want to find the pixels that were generated\n    // for each pixel in the input image the forward pass\n\n    const effectiveXSize = [alignCorners && yHeight > 1 ? xHeight - 1 : xHeight, alignCorners && yWidth > 1 ? xWidth - 1 : xWidth];\n    const effectiveYSize = [alignCorners && yHeight > 1 ? yHeight - 1 : yHeight, alignCorners && yWidth > 1 ? yWidth - 1 : yWidth];\n    const heightScale = effectiveXSize[0] / effectiveYSize[0];\n    const widthScale = effectiveXSize[1] / effectiveYSize[1];\n    const invHeightScale = 1 / heightScale;\n    const invWidthScale = 1 / widthScale; // This defines the size of the window of values around a particular\n    // index in dy that we want to search for contributions to dx.\n\n    const winHeight = Math.ceil(invHeightScale) * 2 + 2;\n    const winWidth = Math.ceil(invWidthScale) * 2 + 2; // Loop over the output space.\n\n    for (let b = 0; b < batch; b++) {\n      const batchOffset = b * x.strides[0];\n\n      for (let r = 0; r < xHeight; r++) {\n        const rowOffset = batchOffset + r * x.strides[1]; // Compute bounds for where in dy we will look\n\n        const startRLerp = Math.floor(r * invHeightScale);\n        const startDyR = Math.floor(startRLerp - winHeight / 2);\n\n        for (let c = 0; c < xWidth; c++) {\n          const colOffset = rowOffset + c * x.strides[2]; // Compute bounds for where in dy we will look\n\n          const startCLerp = Math.floor(c * invWidthScale);\n          const startDyC = Math.floor(startCLerp - winWidth / 2);\n\n          for (let d = 0; d < depth; d++) {\n            let accum = 0; // loop over dy\n\n            for (let dyRIndex = 0; dyRIndex < winHeight; dyRIndex++) {\n              const dyR = dyRIndex + startDyR; // Guard against the window exceeding the bounds of dy\n\n              if (dyR < 0 || dyR >= yHeight) {\n                continue;\n              }\n\n              const dyROffset = batchOffset + dyR * dy.strides[1];\n              const sourceFracRow = dyR * heightScale;\n              const sourceNearestRow = Math.min(xHeight - 1, alignCorners ? Math.round(sourceFracRow) : Math.floor(sourceFracRow));\n\n              if (r !== sourceNearestRow) {\n                continue;\n              }\n\n              for (let dyCIndex = 0; dyCIndex < winWidth; dyCIndex++) {\n                const dyC = dyCIndex + startDyC; // Guard against the window exceeding the bounds of dy\n\n                if (dyC < 0 || dyC >= yWidth) {\n                  continue;\n                }\n\n                const dyCOffset = dyROffset + dyC * dy.strides[2];\n                const sourceFracCol = dyC * widthScale;\n                const sourceNearestCol = Math.min(xWidth - 1, alignCorners ? Math.round(sourceFracCol) : Math.floor(sourceFracCol));\n\n                if (c === sourceNearestCol) {\n                  accum += dyValues[dyCOffset + d];\n                }\n              }\n            }\n\n            output[colOffset + d] = accum;\n          }\n        }\n      }\n    }\n\n    return tf.tensor4d(output, x.shape, x.dtype);\n  }\n\n  localResponseNormalization4D(x, depthRadius, bias, alpha, beta) {\n    assertNotComplex(x, 'localResponseNormalization4D');\n    const channels = x.shape[3];\n    const maxD = channels - 1;\n    const xValues = this.readSync(x.dataId);\n    const size = x.size;\n    const result = new Float32Array(size);\n\n    function sumAcrossChannels(offset) {\n      const currentChannel = offset % channels;\n      let beginSumOffset = offset - currentChannel + Math.max(0, currentChannel - depthRadius);\n      const endSumOffset = offset - currentChannel + Math.min(currentChannel + depthRadius, maxD);\n      let sum = 0.0;\n\n      for (; beginSumOffset <= endSumOffset; beginSumOffset++) {\n        const z = xValues[beginSumOffset];\n        sum += z * z;\n      }\n\n      return sum;\n    }\n\n    for (let offset = 0; offset < size; offset++) {\n      const sum = sumAcrossChannels(offset);\n      const val = xValues[offset] * Math.pow(bias + alpha * sum, -beta);\n      result[offset] = val;\n    }\n\n    return tf.tensor4d(result, x.shape);\n  }\n\n  LRNGrad(dy, inputImage, outputImage, depthRadius, bias, alpha, beta) {\n    assertNotComplex(dy, 'LRNGrad');\n    const channels = dy.shape[3];\n    const dyValues = this.readSync(dy.dataId);\n    const inputImageValues = this.readSync(inputImage.dataId);\n    const outputImageValues = this.readSync(outputImage.dataId);\n    const result = new Float32Array(dy.size);\n    const size = dy.size;\n\n    for (let offset = 0; offset < size; offset++) {\n      const currentChannel = offset % channels;\n      const depthBegin = offset - currentChannel + Math.max(0, currentChannel - depthRadius);\n      const depthEnd = offset - currentChannel + Math.min(channels, currentChannel + depthRadius + 1);\n      let norm = 0;\n\n      for (let k = depthBegin; k < depthEnd; k++) {\n        norm += Math.pow(inputImageValues[k], 2);\n      }\n\n      norm = alpha * norm + bias;\n\n      for (let k = depthBegin; k < depthEnd; k++) {\n        let dyi = -2 * alpha * beta * inputImageValues[k] * outputImageValues[offset] / norm;\n\n        if (offset === k) {\n          dyi += Math.pow(norm, -beta);\n        }\n\n        dyi *= dyValues[offset];\n        result[k] += dyi;\n      }\n    }\n\n    return tf.tensor4d(result, dy.shape);\n  }\n\n  multinomial(logits, normalized, numSamples, seed) {\n    assertNotComplex(logits, 'multinomial');\n    const probabilities = normalized ? logits : tf.softmax(logits);\n    const batchSize = probabilities.shape[0];\n    const numEvents = probabilities.shape[1];\n    const res = tf.zeros([batchSize, numSamples], 'int32');\n    const resVals = this.readSync(res.dataId);\n    const probVals = this.readSync(probabilities.dataId);\n\n    for (let b = 0; b < batchSize; ++b) {\n      const offset = b * numEvents; // The cdf won't include the last event. It will be implicit if no other\n      // event happened.\n\n      const cdf = new Float32Array(numEvents - 1);\n      cdf[0] = probVals[offset];\n\n      for (let event = 1; event < cdf.length; ++event) {\n        cdf[event] = cdf[event - 1] + probVals[offset + event];\n      }\n\n      const random = seedrandom.alea(seed.toString());\n      const outOffset = b * numSamples;\n\n      for (let sampleId = 0; sampleId < numSamples; ++sampleId) {\n        const r = random(); // Assume last event happened by default.\n\n        resVals[outOffset + sampleId] = cdf.length;\n\n        for (let event = 0; event < cdf.length; event++) {\n          if (r < cdf[event]) {\n            resVals[outOffset + sampleId] = event;\n            break;\n          }\n        }\n      }\n    }\n\n    return res;\n  }\n\n  oneHot(indices, depth, onValue, offValue) {\n    assertNotComplex(indices, 'oneHot');\n    const res = new Float32Array(indices.size * depth);\n    res.fill(offValue);\n    const indicesVal = this.readSync(indices.dataId);\n\n    for (let event = 0; event < indices.size; ++event) {\n      if (indicesVal[event] >= 0 && indicesVal[event] < depth) {\n        res[event * depth + indicesVal[event]] = onValue;\n      }\n    }\n\n    return tf.tensor2d(res, [indices.size, depth], 'int32');\n  }\n\n  nonMaxSuppression(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {\n    assertNotComplex(boxes, 'nonMaxSuppression');\n    const boxesVals = this.readSync(boxes.dataId);\n    const scoresVals = this.readSync(scores.dataId);\n    return nonMaxSuppressionV3Impl(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);\n  }\n\n  depthToSpace(x, blockSize, dataFormat) {\n    util.assert(dataFormat === 'NHWC', () => `Only NHWC dataFormat supported on CPU for depthToSpace. Got ${dataFormat}`);\n    util.assert(blockSize > 1, () => `blockSize should be > 1 for depthToSpace, but was: ${blockSize}`);\n    const batchSize = x.shape[0];\n    const inputHeight = x.shape[1];\n    const inputWidth = x.shape[2];\n    const inputDepth = x.shape[3];\n    const outputHeight = inputHeight * blockSize;\n    const outputWidth = inputWidth * blockSize;\n    const outputDepth = inputDepth / (blockSize * blockSize);\n    const xValues = this.readSync(x.dataId);\n    const result = new Float32Array(batchSize * outputHeight * outputWidth * outputDepth);\n    let outputIdx = 0;\n\n    for (let b = 0; b < batchSize; ++b) {\n      for (let h = 0; h < outputHeight; ++h) {\n        const inH = Math.floor(h / blockSize);\n        const offsetH = h % blockSize;\n\n        for (let w = 0; w < outputWidth; ++w) {\n          const inW = Math.floor(w / blockSize);\n          const offsetW = w % blockSize;\n          const offsetD = (offsetH * blockSize + offsetW) * outputDepth;\n\n          for (let d = 0; d < outputDepth; ++d) {\n            const inD = d + offsetD;\n            const inputIdx = inD + inputDepth * (inW + inputWidth * (inH + inputHeight * b));\n            result[outputIdx++] = xValues[inputIdx];\n          }\n        }\n      }\n    }\n\n    return tf.tensor4d(result, [batchSize, outputHeight, outputWidth, outputDepth]);\n  }\n\n  broadcastedBinaryOp(a, b, dtype, op) {\n    const newShape = backend_util.assertAndGetBroadcastShape(a.shape, b.shape);\n    const result = tf.buffer(newShape, dtype);\n    const aVals = this.readSync(a.dataId);\n    const bVals = this.readSync(b.dataId);\n    const aBroadcastDims = backend_util.getBroadcastDims(a.shape, newShape);\n    const bBroadcastDims = backend_util.getBroadcastDims(b.shape, newShape);\n    const resVals = result.values;\n\n    if (aBroadcastDims.length + bBroadcastDims.length === 0) {\n      for (let i = 0; i < resVals.length; ++i) {\n        resVals[i] = op(aVals[i % aVals.length], bVals[i % bVals.length]);\n      }\n    } else {\n      const aBuf = this.bufferSync(a);\n      const bBuf = this.bufferSync(b);\n\n      for (let i = 0; i < resVals.length; ++i) {\n        const loc = result.indexToLoc(i);\n        const aLoc = loc.slice(-a.rank);\n        aBroadcastDims.forEach(d => aLoc[d] = 0);\n        const aIndex = aBuf.locToIndex(aLoc);\n        const bLoc = loc.slice(-b.rank);\n        bBroadcastDims.forEach(d => bLoc[d] = 0);\n        const bIndex = bBuf.locToIndex(bLoc);\n        resVals[i] = op(aVals[aIndex], bVals[bIndex]);\n      }\n    }\n\n    return result.toTensor();\n  }\n\n  split(x, sizeSplits, axis) {\n    return split(x, sizeSplits, axis);\n  }\n\n  dispose() {}\n\n  floatPrecision() {\n    return 32;\n  }\n  /** Returns the smallest representable number.  */\n\n\n  epsilon() {\n    return super.epsilon();\n  }\n\n  cropAndResize(images, boxes, boxIndex, cropSize, method, extrapolationValue) {\n    const [batch, imageHeight, imageWidth, numChannels] = images.shape;\n    const numBoxes = boxes.shape[0];\n    const [cropHeight, cropWidth] = cropSize;\n    const output = tf.buffer([numBoxes, cropHeight, cropWidth, numChannels], 'float32');\n    const boxVals = this.readSync(boxes.dataId);\n    const boxIndVals = this.readSync(boxIndex.dataId);\n    const imageVals = this.readSync(images.dataId);\n    const inStride = images.strides; // to calculate flat indexes into image\n\n    const outStride = output.strides; // to calculate flat indexes into output\n    // Reference implementation\n    // tslint:disable-next-line:max-line-length\n    // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/crop_and_resize_op.cc\n\n    for (let b = 0; b < numBoxes; b++) {\n      const startInd = b * 4;\n      const y1 = boxVals[startInd];\n      const x1 = boxVals[startInd + 1];\n      const y2 = boxVals[startInd + 2];\n      const x2 = boxVals[startInd + 3];\n      const bInd = boxIndVals[b];\n\n      if (bInd >= batch) {\n        continue;\n      }\n\n      const heightScale = cropHeight > 1 ? (y2 - y1) * (imageHeight - 1) / (cropHeight - 1) : 0;\n      const widthScale = cropWidth > 1 ? (x2 - x1) * (imageWidth - 1) / (cropWidth - 1) : 0;\n\n      for (let y = 0; y < cropHeight; y++) {\n        const yInd = cropHeight > 1 ? y1 * (imageHeight - 1) + y * heightScale : 0.5 * (y1 + y2) * (imageHeight - 1);\n\n        if (yInd < 0 || yInd > imageHeight - 1) {\n          for (let x = 0; x < cropWidth; x++) {\n            for (let c = 0; c < numChannels; c++) {\n              const ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n              output.values[ind] = extrapolationValue;\n            }\n          }\n\n          continue;\n        }\n\n        if (method === 'bilinear') {\n          const topInd = Math.floor(yInd);\n          const bottomInd = Math.ceil(yInd);\n          const yLerp = yInd - topInd;\n\n          for (let x = 0; x < cropWidth; x++) {\n            const xInd = cropWidth > 1 ? x1 * (imageWidth - 1) + x * widthScale : 0.5 * (x1 + x2) * (imageWidth - 1);\n\n            if (xInd < 0 || xInd > imageWidth - 1) {\n              for (let c = 0; c < numChannels; c++) {\n                const ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n                output.values[ind] = extrapolationValue;\n              }\n\n              continue;\n            }\n\n            const leftInd = Math.floor(xInd);\n            const rightInd = Math.ceil(xInd);\n            const xLerp = xInd - leftInd;\n\n            for (let c = 0; c < numChannels; c++) {\n              let ind = c + leftInd * inStride[2] + topInd * inStride[1] + bInd * inStride[0];\n              const topLeft = imageVals[ind];\n              ind = c + rightInd * inStride[2] + topInd * inStride[1] + bInd * inStride[0];\n              const topRight = imageVals[ind];\n              ind = c + leftInd * inStride[2] + bottomInd * inStride[1] + bInd * inStride[0];\n              const bottomLeft = imageVals[ind];\n              ind = c + rightInd * inStride[2] + bottomInd * inStride[1] + bInd * inStride[0];\n              const bottomRight = imageVals[ind];\n              const top = topLeft + (topRight - topLeft) * xLerp;\n              const bottom = bottomLeft + (bottomRight - bottomLeft) * xLerp;\n              ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n              output.values[ind] = top + (bottom - top) * yLerp;\n            }\n          }\n        } else {\n          // method == \"nearest\"\n          for (let x = 0; x < cropWidth; ++x) {\n            const xInd = cropWidth > 1 ? x1 * (imageWidth - 1) + x * widthScale : 0.5 * (x1 + x2) * (imageWidth - 1);\n\n            if (xInd < 0 || xInd > imageWidth - 1) {\n              for (let c = 0; c < numChannels; c++) {\n                const ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n                output.values[ind] = extrapolationValue;\n              }\n\n              continue;\n            }\n\n            const closestX = Math.round(xInd);\n            const closestY = Math.round(yInd);\n\n            for (let c = 0; c < numChannels; c++) {\n              const inInd = c + closestX * inStride[2] + closestY * inStride[1] + bInd * inStride[0];\n              const outInd = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n              output.values[outInd] = imageVals[inInd];\n            }\n          }\n        }\n      }\n    }\n\n    return output.toTensor();\n  }\n\n  sparseToDense(sparseIndices, sparseValues, outputShape, defaultValue) {\n    const {\n      sliceRank,\n      numUpdates,\n      sliceSize,\n      strides,\n      outputSize\n    } = backend_util.calculateShapes(sparseValues, sparseIndices, outputShape);\n    const sumDupeIndices = false;\n    return this.scatter(sparseIndices, sparseValues, outputShape, outputSize, sliceSize, numUpdates, sliceRank, strides, defaultValue, sumDupeIndices);\n  }\n\n  gatherND(x, indices) {\n    const indicesShape = indices.shape;\n    const sliceRank = indicesShape[indicesShape.length - 1];\n    const [resultShape, numSlices, sliceSize, strides] = backend_util.prepareAndValidate(x, indices);\n\n    if (numSlices === 0) {\n      return tf.tensor([], resultShape, x.dtype);\n    }\n\n    const buffer = new TensorBuffer([numSlices, sliceSize], x.dtype);\n    const indicesData = this.readSync(indices.dataId);\n    const xData = this.readSync(x.dataId);\n\n    for (let i = 0; i < numSlices; i++) {\n      const index = [];\n      let flattenIndex = 0;\n\n      for (let j = 0; j < sliceRank; j++) {\n        const dim = indicesData[i * sliceRank + j];\n        flattenIndex += dim * strides[j];\n        index.push(dim);\n      }\n\n      if (flattenIndex < 0 || flattenIndex >= x.size / sliceSize) {\n        throw new Error(`Invalid indices: ${index} does not index into ${x.shape}`);\n      }\n\n      for (let k = 0; k < sliceSize; k++) {\n        buffer.values[i * sliceSize + k] = xData[flattenIndex * sliceSize + k];\n      }\n    }\n\n    return buffer.toTensor().reshape(resultShape);\n  }\n\n  scatterND(indices, updates, shape) {\n    const {\n      sliceRank,\n      numUpdates,\n      sliceSize,\n      strides,\n      outputSize\n    } = backend_util.calculateShapes(updates, indices, shape);\n    const defaultValue = tf.scalar(0);\n    const sumDupeIndices = true;\n    return this.scatter(indices, updates, shape, outputSize, sliceSize, numUpdates, sliceRank, strides, defaultValue, sumDupeIndices);\n  }\n\n  onesLike(x) {\n    if (x.dtype === 'string') {\n      throw new Error('onesLike is not supported for string tensors');\n    } else {\n      // TODO(lina128): Use fill kernel directly once this kernel is\n      // modularized.\n      return tf.fill(x.shape, 1, x.dtype);\n    }\n  }\n\n  zerosLike(x) {\n    const values = util.getArrayFromDType(x.dtype, util.sizeFromShape(x.shape));\n    return this.makeOutput(values, x.shape, x.dtype);\n  }\n\n  linspace(start, stop, num) {\n    return backend_util.linspaceImpl(start, stop, num);\n  }\n\n  scatter(indices, updates, shape, outputSize, sliceSize, numUpdates, sliceRank, strides, defaultValue, sumDupeIndices) {\n    const flattenShape = [outputSize / sliceSize, sliceSize];\n    const indicesData = this.readSync(indices.dataId);\n    const updatesData = this.readSync(updates.dataId);\n\n    if (outputSize === 0) {\n      return tf.tensor([], shape, updates.dtype);\n    }\n\n    const buffer = new TensorBuffer(flattenShape, updates.dtype);\n    buffer.values.fill(this.readSync(defaultValue.dataId)[0]);\n\n    for (let i = 0; i < numUpdates; i++) {\n      const index = [];\n      let flattenIndex = 0;\n\n      for (let j = 0; j < sliceRank; j++) {\n        const dim = indicesData[i * sliceRank + j];\n        index.push(dim);\n        flattenIndex += dim * strides[j];\n      }\n\n      if (flattenIndex < 0 || flattenIndex >= outputSize / sliceSize) {\n        throw new Error(`Invalid indices: ${index} does not index into ${shape}`);\n      }\n\n      for (let k = 0; k < sliceSize; k++) {\n        if (sumDupeIndices) {\n          buffer.values[flattenIndex * sliceSize + k] += updatesData[i * sliceSize + k];\n        } else {\n          buffer.values[flattenIndex * sliceSize + k] = updates.rank === 0 ? updatesData[0] : updatesData[i * sliceSize + k];\n        }\n      }\n    }\n\n    return buffer.toTensor().reshape(shape);\n  }\n\n}","map":{"version":3,"sources":["../src/backend_cpu.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as tf from '@tensorflow/tfjs-core';\nimport { backend_util, DataStorage, engine, env, kernel_impls, KernelBackend, max, slice_util, TensorBuffer, upcastType, util } from '@tensorflow/tfjs-core';\nconst nonMaxSuppressionV3Impl = kernel_impls.nonMaxSuppressionV3Impl;\nconst split = kernel_impls.split;\nconst tile = kernel_impls.tile;\nconst topkImpl = kernel_impls.topkImpl;\nconst whereImpl = kernel_impls.whereImpl;\nimport * as seedrandom from 'seedrandom';\nimport { assertNotComplex } from './cpu_util';\nexport class MathBackendCPU extends KernelBackend {\n    constructor() {\n        super();\n        this.blockSize = 48;\n        this.firstUse = true;\n        this.data = new DataStorage(this, engine());\n    }\n    write(values, shape, dtype) {\n        if (this.firstUse) {\n            this.firstUse = false;\n            if (env().get('IS_NODE')) {\n                backend_util.warn('\\n============================\\n' +\n                    'Hi there ðŸ‘‹. Looks like you are running TensorFlow.js in ' +\n                    'Node.js. To speed things up dramatically, install our node ' +\n                    'backend, which binds to TensorFlow C++, by running ' +\n                    'npm i @tensorflow/tfjs-node, ' +\n                    'or npm i @tensorflow/tfjs-node-gpu if you have CUDA. ' +\n                    'Then call require(\\'@tensorflow/tfjs-node\\'); (-gpu ' +\n                    'suffix for CUDA) at the start of your program. ' +\n                    'Visit https://github.com/tensorflow/tfjs-node for more details.' +\n                    '\\n============================');\n            }\n        }\n        const dataId = {};\n        this.data.set(dataId, { values, dtype, refCount: 1 });\n        return dataId;\n    }\n    /**\n     * Create a data bucket in cpu backend.\n     * @param shape Shape of the `TensorInfo`.\n     * @param dtype DType of the `TensorInfo`.\n     * @param values The value of the `TensorInfo` stored as a flattened array.\n     */\n    makeTensorInfo(shape, dtype, values) {\n        let outId;\n        if (dtype === 'string' && values != null && values.length > 0 &&\n            util.isString(values[0])) {\n            const encodedValues = values.map(d => util.encodeString(d));\n            outId = this.write(encodedValues, shape, dtype);\n        }\n        else {\n            outId = this.write(values, shape, dtype);\n        }\n        return { dataId: outId, shape, dtype };\n    }\n    /** Increase refCount of a `TensorData`. */\n    incRef(dataId) {\n        const tensorData = this.data.get(dataId);\n        tensorData.refCount++;\n    }\n    /** Decrease refCount of a `TensorData`. */\n    decRef(dataId) {\n        if (this.data.has(dataId)) {\n            const tensorData = this.data.get(dataId);\n            tensorData.refCount--;\n        }\n    }\n    move(dataId, values, shape, dtype) {\n        this.data.set(dataId, { values, dtype, refCount: 1 });\n    }\n    numDataIds() {\n        return this.data.numDataIds();\n    }\n    async read(dataId) {\n        return this.readSync(dataId);\n    }\n    readSync(dataId) {\n        const { dtype, complexTensorInfos } = this.data.get(dataId);\n        if (dtype === 'complex64') {\n            const realValues = this.readSync(complexTensorInfos.real.dataId);\n            const imagValues = this.readSync(complexTensorInfos.imag.dataId);\n            return backend_util.mergeRealAndImagArrays(realValues, imagValues);\n        }\n        return this.data.get(dataId).values;\n    }\n    bufferSync(t) {\n        const data = this.readSync(t.dataId);\n        let decodedData = data;\n        if (t.dtype === 'string') {\n            try {\n                // Decode the bytes into string.\n                decodedData = data.map(d => util.decodeString(d));\n            }\n            catch (_a) {\n                throw new Error('Failed to decode encoded string bytes into utf-8');\n            }\n        }\n        return tf.buffer(t.shape, t.dtype, decodedData);\n    }\n    makeOutput(values, shape, dtype) {\n        const dataId = this.write(values, shape, dtype);\n        return engine().makeTensorFromDataId(dataId, shape, dtype, this);\n    }\n    disposeData(dataId) {\n        if (this.data.has(dataId)) {\n            const { complexTensorInfos } = this.data.get(dataId);\n            if (complexTensorInfos != null) {\n                this.disposeData(complexTensorInfos.real.dataId);\n                this.disposeData(complexTensorInfos.imag.dataId);\n            }\n            this.data.delete(dataId);\n        }\n    }\n    disposeIntermediateTensorInfo(tensorInfo) {\n        const dataId = tensorInfo.dataId;\n        if (this.data.has(dataId)) {\n            const tensorData = this.data.get(dataId);\n            tensorData.refCount--;\n            if (tensorData.refCount < 1) {\n                this.disposeData(dataId);\n            }\n        }\n    }\n    async time(f) {\n        const start = util.now();\n        f();\n        const kernelMs = util.now() - start;\n        return { kernelMs };\n    }\n    memory() {\n        return {\n            // Unreliable due to automatic gc. The numbers above are cumulative.\n            unreliable: true,\n            reasons: ['The reported memory is an upper bound. Due to automatic garbage ' +\n                    'collection, the true allocated memory may be less.']\n        };\n    }\n    stridedSlice(x, begin, end, strides) {\n        assertNotComplex(x, 'stridedSlice');\n        const outShape = slice_util.computeOutShape(begin, end, strides);\n        if (outShape.some(axis => axis === 0)) {\n            return tf.tensor([], outShape);\n        }\n        const buffer = tf.buffer(outShape, x.dtype);\n        const xBuf = this.bufferSync(x);\n        for (let i = 0; i < buffer.size; i++) {\n            const loc = buffer.indexToLoc(i);\n            const newLoc = new Array(loc.length);\n            for (let j = 0; j < newLoc.length; j++) {\n                newLoc[j] = loc[j] * strides[j] + begin[j];\n            }\n            buffer.set(xBuf.get(...newLoc), ...loc);\n        }\n        return buffer.toTensor();\n    }\n    diag(x) {\n        const xVals = this.readSync(x.dataId);\n        const buffer = tf.buffer([x.size, x.size], x.dtype);\n        const vals = buffer.values;\n        for (let i = 0; i < xVals.length; i++) {\n            vals[i * x.size + i] = xVals[i];\n        }\n        return buffer.toTensor();\n    }\n    unstack(x, axis) {\n        const num = x.shape[axis];\n        const outShape = new Array(x.rank - 1);\n        let outIndex = 0;\n        for (let i = 0; i < x.rank; i++) {\n            if (i !== axis) {\n                outShape[outIndex++] = x.shape[i];\n            }\n        }\n        const begin = new Array(x.rank).fill(0);\n        const size = x.shape.slice();\n        size[axis] = 1;\n        const res = new Array(num);\n        for (let i = 0; i < res.length; i++) {\n            begin[axis] = i;\n            res[i] = tf.slice(x, begin, size).reshape(outShape);\n        }\n        return res;\n    }\n    reverse(x, axis) {\n        assertNotComplex(x, 'reverse');\n        const buffer = tf.buffer(x.shape, x.dtype);\n        const xBuf = this.bufferSync(x);\n        for (let i = 0; i < buffer.size; i++) {\n            const outLoc = buffer.indexToLoc(i);\n            const inLoc = outLoc.slice();\n            axis.forEach(ax => inLoc[ax] = x.shape[ax] - 1 - inLoc[ax]);\n            buffer.set(xBuf.get(...inLoc), ...outLoc);\n        }\n        return buffer.toTensor();\n    }\n    neg(x) {\n        assertNotComplex(x, 'neg');\n        // TODO(lina128): Use mul directly once neg is modularized.\n        return tf.mul(tf.scalar(-1), x);\n    }\n    addN(tensors) {\n        assertNotComplex(tensors, 'addN');\n        const vals = tensors.map(t => this.readSync(t.dataId));\n        const result = tf.buffer(tensors[0].shape, tensors[0].dtype);\n        const resultVals = result.values;\n        for (let i = 0; i < tensors.length; i++) {\n            const currVals = vals[i];\n            for (let j = 0; j < resultVals.length; j++) {\n                resultVals[j] += currVals[j];\n            }\n        }\n        return result.toTensor();\n    }\n    softmax(logits, dim) {\n        const axes = util.parseAxisParam([dim], logits.shape);\n        // TODO(annxingyuan): Call maxImpl rather than op as part of softmax kernel\n        // modularization.\n        const maxLogit = max(logits, axes);\n        const expandedShape = backend_util.expandShapeToKeepDim(maxLogit.shape, axes);\n        // TODO(lina128): Use sub directly once softmax is modularized.\n        const a = tf.sub(logits, maxLogit.reshape(expandedShape));\n        const b = tf.exp(a);\n        const sumExp = this.sum(b, axes).reshape(expandedShape);\n        // TODO(annxingyuan): Call divImpl rather than op as part of softmax\n        // kernel modularization.\n        return tf.div(b, sumExp);\n    }\n    pow(a, b) {\n        assertNotComplex([a, b], 'pow');\n        return this.broadcastedBinaryOp(a, b, a.dtype, (aValue, bValue) => Math.pow(aValue, bValue));\n    }\n    floorDiv(a, b) {\n        assertNotComplex([a, b], 'floorDiv');\n        const op = (a, b) => Math.floor(a / b);\n        const outputDtype = 'int32';\n        return this.broadcastedBinaryOp(a, b, outputDtype, op);\n    }\n    sum(x, axes) {\n        assertNotComplex(x, 'sum');\n        backend_util.assertAxesAreInnerMostDims('sum', axes, x.rank);\n        const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(x.shape, axes);\n        const resultDtype = upcastType(x.dtype, 'int32');\n        const result = tf.zeros(outShape, resultDtype);\n        const reduceSize = util.sizeFromShape(reduceShape);\n        const vals = this.readSync(result.dataId);\n        const aVals = this.readSync(x.dataId);\n        for (let i = 0; i < vals.length; ++i) {\n            const offset = i * reduceSize;\n            let sum = 0;\n            for (let j = 0; j < reduceSize; ++j) {\n                sum += aVals[offset + j];\n            }\n            vals[i] = sum;\n        }\n        return result;\n    }\n    prod(x, axes) {\n        assertNotComplex(x, 'sum');\n        const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(x.shape, axes);\n        const resultDtype = upcastType(x.dtype, 'int32');\n        const result = tf.zeros(outShape, resultDtype);\n        const reduceSize = util.sizeFromShape(reduceShape);\n        const vals = this.readSync(result.dataId);\n        const aVals = this.readSync(x.dataId);\n        for (let i = 0; i < vals.length; ++i) {\n            const offset = i * reduceSize;\n            let prod = 1;\n            for (let j = 0; j < reduceSize; ++j) {\n                prod *= aVals[offset + j];\n            }\n            vals[i] = prod;\n        }\n        return result;\n    }\n    unsortedSegmentSum(x, segmentIds, numSegments) {\n        assertNotComplex(x, 'unsortedSegmentSum');\n        const res = [];\n        // Reshape the segment id's so that they can be broadcast with\n        // x. The new shape should be [segmentIds.shape, 1, ..., 1]\n        const numIters = x.rank - segmentIds.rank;\n        for (let i = 0; i < numIters; ++i) {\n            segmentIds = segmentIds.expandDims(i + 1);\n        }\n        for (let i = 0; i < numSegments; ++i) {\n            const segmentId = tf.scalar(i, 'int32');\n            const mask = tf.equal(segmentId, segmentIds).asType('float32');\n            const sum = mask.mul(x).sum(0);\n            res.push(sum);\n        }\n        return tf.stack(res);\n    }\n    argMin(x, axis) {\n        assertNotComplex(x, 'argMin');\n        const axes = [axis];\n        backend_util.assertAxesAreInnerMostDims('argMin', axes, x.rank);\n        const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(x.shape, axes);\n        const result = tf.zeros(outShape, 'int32');\n        const reduceSize = util.sizeFromShape(reduceShape);\n        const vals = this.readSync(result.dataId);\n        const aVals = this.readSync(x.dataId);\n        for (let i = 0; i < vals.length; ++i) {\n            const offset = i * reduceSize;\n            let min = aVals[offset];\n            let minIndex = 0;\n            for (let j = 0; j < reduceSize; ++j) {\n                const value = aVals[offset + j];\n                if (value < min) {\n                    min = value;\n                    minIndex = j;\n                }\n            }\n            vals[i] = minIndex;\n        }\n        return result;\n    }\n    argMax(x, axis) {\n        assertNotComplex(x, 'argMax');\n        const axes = [axis];\n        backend_util.assertAxesAreInnerMostDims('argMax', axes, x.rank);\n        const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(x.shape, axes);\n        const result = tf.zeros(outShape, 'int32');\n        const reduceSize = util.sizeFromShape(reduceShape);\n        const vals = this.readSync(result.dataId);\n        const aVals = this.readSync(x.dataId);\n        for (let i = 0; i < vals.length; ++i) {\n            const offset = i * reduceSize;\n            let max = aVals[offset];\n            let maxIndex = 0;\n            for (let j = 0; j < reduceSize; ++j) {\n                const value = aVals[offset + j];\n                if (value > max) {\n                    max = value;\n                    maxIndex = j;\n                }\n            }\n            vals[i] = maxIndex;\n        }\n        return result;\n    }\n    cumsum(x, axis, exclusive, reverse) {\n        assertNotComplex(x, 'cumsum');\n        if (axis !== x.rank - 1) {\n            throw new Error(`backend.cumsum in CPU expects an inner-most axis=${x.rank - 1} ` +\n                `but got axis=${axis}`);\n        }\n        const resultDtype = upcastType(x.dtype, 'int32');\n        const result = tf.zeros(x.shape, resultDtype);\n        const vals = this.readSync(result.dataId);\n        const aVals = this.readSync(x.dataId);\n        const finalDim = x.shape[x.rank - 1];\n        const indexAdjuster = reverse ?\n            (i, j) => i + finalDim - j - 1 :\n            (i, j) => i + j;\n        for (let i = 0; i < aVals.length; i += finalDim) {\n            for (let j = 0; j < finalDim; j++) {\n                const idx = indexAdjuster(i, j);\n                if (j === 0) {\n                    vals[idx] = exclusive ? 0 : aVals[idx];\n                }\n                else {\n                    const prevIdx = indexAdjuster(i, j - 1);\n                    vals[idx] = exclusive ? aVals[prevIdx] + vals[prevIdx] :\n                        aVals[idx] + vals[prevIdx];\n                }\n            }\n        }\n        return result;\n    }\n    equal(a, b) {\n        assertNotComplex([a, b], 'equal');\n        return this.broadcastedBinaryOp(a, b, 'bool', (aVal, bVal) => {\n            return (aVal === bVal) ? 1 : 0;\n        });\n    }\n    notEqual(a, b) {\n        assertNotComplex([a, b], 'notEqual');\n        return this.broadcastedBinaryOp(a, b, 'bool', (aVal, bVal) => {\n            return (aVal !== bVal) ? 1 : 0;\n        });\n    }\n    less(a, b) {\n        assertNotComplex([a, b], 'less');\n        return this.broadcastedBinaryOp(a, b, 'bool', (aVal, bVal) => {\n            return (aVal < bVal) ? 1 : 0;\n        });\n    }\n    lessEqual(a, b) {\n        assertNotComplex([a, b], 'lessEqual');\n        return this.broadcastedBinaryOp(a, b, 'bool', (aVal, bVal) => {\n            return (aVal <= bVal) ? 1 : 0;\n        });\n    }\n    greater(a, b) {\n        assertNotComplex([a, b], 'greater');\n        return this.broadcastedBinaryOp(a, b, 'bool', (aVal, bVal) => {\n            return (aVal > bVal) ? 1 : 0;\n        });\n    }\n    greaterEqual(a, b) {\n        assertNotComplex([a, b], 'greaterEqual');\n        return this.broadcastedBinaryOp(a, b, 'bool', (aVal, bVal) => {\n            return (aVal >= bVal) ? 1 : 0;\n        });\n    }\n    logicalAnd(a, b) {\n        assertNotComplex([a, b], 'logicalAnd');\n        return this.broadcastedBinaryOp(a, b, 'bool', (aVal, bVal) => {\n            return aVal && bVal;\n        });\n    }\n    logicalOr(a, b) {\n        assertNotComplex([a, b], 'logicalOr');\n        return this.broadcastedBinaryOp(a, b, 'bool', (aVal, bVal) => {\n            return aVal || bVal;\n        });\n    }\n    select(condition, a, b) {\n        assertNotComplex([condition, a, b], 'select');\n        const values = this.readSync(condition.dataId);\n        const aValues = this.readSync(a.dataId);\n        const bValues = this.readSync(b.dataId);\n        const result = tf.zeros(a.shape, upcastType(a.dtype, b.dtype));\n        const newValues = this.readSync(result.dataId);\n        let index = 0;\n        const offset = condition.rank === 0 || condition.rank > 1 || a.rank === 1 ?\n            1 :\n            util.sizeFromShape(a.shape.slice(1));\n        for (let i = 0; i < values.length; i++) {\n            for (let j = 0; j < offset; j++) {\n                if (values[i] === 1) {\n                    newValues[index++] = aValues[i];\n                }\n                else {\n                    newValues[index++] = bValues[i];\n                }\n            }\n        }\n        return result;\n    }\n    where(condition) {\n        assertNotComplex([condition], 'where');\n        const condVals = this.readSync(condition.dataId);\n        return whereImpl(condition.shape, condVals);\n    }\n    topk(x, k, sorted) {\n        assertNotComplex(x, 'topk');\n        const xVals = this.readSync(x.dataId);\n        return topkImpl(xVals, x.shape, x.dtype, k, sorted);\n    }\n    min(x, axes) {\n        assertNotComplex(x, 'min');\n        backend_util.assertAxesAreInnerMostDims('min', axes, x.rank);\n        const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(x.shape, axes);\n        const result = tf.zeros(outShape, x.dtype);\n        const reduceSize = util.sizeFromShape(reduceShape);\n        const vals = this.readSync(result.dataId);\n        const aVals = this.readSync(x.dataId);\n        for (let i = 0; i < vals.length; ++i) {\n            const offset = i * reduceSize;\n            let min = aVals[offset];\n            for (let j = 0; j < reduceSize; ++j) {\n                const value = aVals[offset + j];\n                if (value < min) {\n                    min = value;\n                }\n            }\n            vals[i] = min;\n        }\n        return result;\n    }\n    minimum(a, b) {\n        assertNotComplex([a, b], 'minimum');\n        return this.broadcastedBinaryOp(a, b, a.dtype, (aVal, bVal) => Math.min(aVal, bVal));\n    }\n    mod(a, b) {\n        assertNotComplex([a, b], 'mod');\n        return this.broadcastedBinaryOp(a, b, a.dtype, (aVal, bVal) => {\n            const rem = aVal % bVal;\n            if ((aVal < 0 && bVal < 0) || (aVal >= 0 && bVal >= 0)) {\n                return rem;\n            }\n            else {\n                return (rem + bVal) % bVal;\n            }\n        });\n    }\n    maximum(a, b) {\n        assertNotComplex([a, b], 'maximum');\n        return this.broadcastedBinaryOp(a, b, a.dtype, (aVal, bVal) => Math.max(aVal, bVal));\n    }\n    all(x, axes) {\n        assertNotComplex(x, 'all');\n        backend_util.assertAxesAreInnerMostDims('all', axes, x.rank);\n        const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(x.shape, axes);\n        const result = tf.zeros(outShape, x.dtype);\n        const reduceSize = util.sizeFromShape(reduceShape);\n        const vals = this.readSync(result.dataId);\n        const aVals = this.readSync(x.dataId);\n        for (let i = 0; i < vals.length; ++i) {\n            const offset = i * reduceSize;\n            let all = aVals[offset];\n            for (let j = 0; j < reduceSize; ++j) {\n                const value = aVals[offset + j];\n                all = all && value;\n            }\n            vals[i] = all;\n        }\n        return result;\n    }\n    any(x, axes) {\n        assertNotComplex(x, 'any');\n        backend_util.assertAxesAreInnerMostDims('any', axes, x.rank);\n        const [outShape, reduceShape] = backend_util.computeOutAndReduceShapes(x.shape, axes);\n        const result = tf.zeros(outShape, x.dtype);\n        const reduceSize = util.sizeFromShape(reduceShape);\n        const vals = this.readSync(result.dataId);\n        const aVals = this.readSync(x.dataId);\n        for (let i = 0; i < vals.length; ++i) {\n            const offset = i * reduceSize;\n            let anyVal = aVals[offset];\n            for (let j = 0; j < reduceSize; ++j) {\n                const value = aVals[offset + j];\n                anyVal = anyVal || value;\n            }\n            vals[i] = anyVal;\n        }\n        return result;\n    }\n    squaredDifference(a, b) {\n        assertNotComplex([a, b], 'squaredDifference');\n        return this.broadcastedBinaryOp(a, b, a.dtype, (aVal, bVal) => {\n            const diff = aVal - bVal;\n            return diff * diff;\n        });\n    }\n    eluDer(dy, y) {\n        assertNotComplex([dy, y], 'eluDer');\n        const resultValues = new Float32Array(y.size);\n        const values = this.readSync(y.dataId);\n        const dyValues = this.readSync(dy.dataId);\n        for (let i = 0; i < values.length; ++i) {\n            const v = values[i];\n            if (v >= 1) {\n                resultValues[i] = dyValues[i];\n            }\n            else {\n                resultValues[i] = dyValues[i] * (v + 1);\n            }\n        }\n        return this.makeOutput(resultValues, y.shape, 'float32');\n    }\n    atan2(a, b) {\n        assertNotComplex([a, b], 'atan2');\n        return this.broadcastedBinaryOp(a, b, a.dtype, (aValue, bValue) => Math.atan2(aValue, bValue));\n    }\n    tile(x, reps) {\n        assertNotComplex(x, 'tile');\n        return tile(this.bufferSync(x), reps);\n    }\n    gather(x, indices, axis) {\n        assertNotComplex([x, indices], 'gather');\n        const newShape = x.shape.slice();\n        const indicesValues = this.readSync(indices.dataId);\n        newShape[axis] = indicesValues.length;\n        const result = tf.buffer(newShape, x.dtype);\n        const xBuf = this.bufferSync(x);\n        for (let i = 0; i < result.size; ++i) {\n            const newLoc = result.indexToLoc(i);\n            const originalLoc = newLoc.slice();\n            originalLoc[axis] = indicesValues[newLoc[axis]];\n            const originalIndex = xBuf.locToIndex(originalLoc);\n            result.values[i] = xBuf.values[originalIndex];\n        }\n        return result.toTensor();\n    }\n    batchToSpaceND(x, blockShape, crops) {\n        assertNotComplex([x], 'batchToSpaceND');\n        const prod = blockShape.reduce((a, b) => a * b);\n        const reshaped = backend_util.getReshaped(x.shape, blockShape, prod);\n        const permuted = backend_util.getPermuted(reshaped.length, blockShape.length);\n        const reshapedPermuted = backend_util.getReshapedPermuted(x.shape, blockShape, prod);\n        const sliceBeginCoords = backend_util.getSliceBeginCoords(crops, blockShape.length);\n        const sliceSize = backend_util.getSliceSize(reshapedPermuted, crops, blockShape.length);\n        return tf.transpose(x.reshape(reshaped), permuted)\n            .reshape(reshapedPermuted)\n            .slice(sliceBeginCoords, sliceSize);\n    }\n    pool3d(x, convInfo, poolType) {\n        assertNotComplex(x, 'pool3d');\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationDepth = convInfo.dilationDepth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n        const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        const padFront = convInfo.padInfo.front;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        const initialValue = (poolType === 'max' ? Number.NEGATIVE_INFINITY :\n            Number.POSITIVE_INFINITY);\n        const xValues = this.readSync(x.dataId);\n        const output = tf.buffer(convInfo.outShape, x.dtype);\n        const outputVals = output.values;\n        const outputBatchStrides = convInfo.outShape[1] * convInfo.outShape[2] *\n            convInfo.outShape[3] * convInfo.outShape[4];\n        const outputDepthStrides = convInfo.outShape[2] * convInfo.outShape[3] * convInfo.outShape[4];\n        const outputRowStrides = convInfo.outShape[3] * convInfo.outShape[4];\n        const outputColStrides = convInfo.outShape[4];\n        for (let batch = 0; batch < convInfo.batchSize; ++batch) {\n            const outputBatchOffset = batch * outputBatchStrides;\n            const inputBatchOffset = batch * x.strides[0];\n            for (let channel = 0; channel < convInfo.inChannels; ++channel) {\n                for (let yDepth = 0; yDepth < convInfo.outDepth; ++yDepth) {\n                    const xDepthCorner = yDepth * strideDepth - padFront;\n                    let xDepthMin = xDepthCorner;\n                    while (xDepthMin < 0) {\n                        xDepthMin += dilationDepth;\n                    }\n                    const xDepthMax = Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);\n                    const outputDepthOffset = outputBatchOffset + yDepth * outputDepthStrides;\n                    for (let yRow = 0; yRow < convInfo.outHeight; ++yRow) {\n                        const xRowCorner = yRow * strideHeight - padTop;\n                        let xRowMin = xRowCorner;\n                        while (xRowMin < 0) {\n                            xRowMin += dilationHeight;\n                        }\n                        const xRowMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);\n                        const outputRowOffset = outputDepthOffset + yRow * outputRowStrides;\n                        for (let yCol = 0; yCol < convInfo.outWidth; ++yCol) {\n                            const xColCorner = yCol * strideWidth - padLeft;\n                            let xColMin = xColCorner;\n                            while (xColMin < 0) {\n                                xColMin += dilationWidth;\n                            }\n                            const xColMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner);\n                            // Shader code begins\n                            const outputColOffset = outputRowOffset + yCol * outputColStrides;\n                            let minMaxValue = initialValue;\n                            let avgValue = 0;\n                            let count = 0;\n                            for (let xDepth = xDepthMin; xDepth < xDepthMax; xDepth += dilationDepth) {\n                                const xDepthOffset = inputBatchOffset + xDepth * x.strides[1];\n                                for (let xRow = xRowMin; xRow < xRowMax; xRow += dilationHeight) {\n                                    const xRowOffset = xDepthOffset + xRow * x.strides[2];\n                                    for (let xCol = xColMin; xCol < xColMax; xCol += dilationWidth) {\n                                        const xColOffset = xRowOffset + xCol * x.strides[3];\n                                        const pixel = xValues[xColOffset + channel];\n                                        if ((poolType === 'max' && pixel > minMaxValue)) {\n                                            minMaxValue = pixel;\n                                        }\n                                        else if (poolType === 'avg') {\n                                            avgValue += pixel;\n                                            count++;\n                                        }\n                                        if (isNaN(minMaxValue)) {\n                                            break;\n                                        }\n                                    }\n                                    if (isNaN(minMaxValue)) {\n                                        break;\n                                    }\n                                }\n                                if (isNaN(minMaxValue)) {\n                                    break;\n                                }\n                            }\n                            const outputOffset = outputColOffset + channel;\n                            outputVals[outputOffset] =\n                                poolType === 'avg' ? avgValue / count : minMaxValue;\n                        }\n                    }\n                }\n            }\n        }\n        return output.toTensor();\n    }\n    avgPool3d(x, convInfo) {\n        assertNotComplex(x, 'avgPool3d');\n        return this.pool3d(x, convInfo, 'avg').toFloat();\n    }\n    avgPool3dBackprop(dy, x, convInfo) {\n        assertNotComplex([dy, x], 'avgPool3dBackprop');\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const filterDepth = convInfo.filterDepth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const dilationDepth = convInfo.dilationDepth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n        const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;\n        const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n        const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n        const dx = tf.buffer(x.shape, 'float32');\n        const avgMultiplier = 1 / (filterDepth * filterHeight * filterWidth);\n        const dyBuf = this.bufferSync(dy);\n        for (let batch = 0; batch < convInfo.batchSize; ++batch) {\n            for (let channel = 0; channel < convInfo.inChannels; ++channel) {\n                for (let dxDepth = 0; dxDepth < convInfo.inDepth; ++dxDepth) {\n                    for (let dxRow = 0; dxRow < convInfo.inHeight; ++dxRow) {\n                        for (let dxCol = 0; dxCol < convInfo.inWidth; ++dxCol) {\n                            // Shader code begins.\n                            const dyDepthCorner = dxDepth - padFront;\n                            const dyRowCorner = dxRow - padTop;\n                            const dyColCorner = dxCol - padLeft;\n                            let dotProd = 0;\n                            for (let wDepth = 0; wDepth < effectiveFilterDepth; wDepth += dilationDepth) {\n                                const dyDepth = (dyDepthCorner + wDepth) / strideDepth;\n                                if (dyDepth < 0 || dyDepth >= convInfo.outDepth ||\n                                    Math.floor(dyDepth) !== dyDepth) {\n                                    continue;\n                                }\n                                for (let wRow = 0; wRow < effectiveFilterHeight; wRow += dilationHeight) {\n                                    const dyRow = (dyRowCorner + wRow) / strideHeight;\n                                    if (dyRow < 0 || dyRow >= convInfo.outHeight ||\n                                        Math.floor(dyRow) !== dyRow) {\n                                        continue;\n                                    }\n                                    for (let wCol = 0; wCol < effectiveFilterWidth; wCol += dilationWidth) {\n                                        const dyCol = (dyColCorner + wCol) / strideWidth;\n                                        if (dyCol < 0 || dyCol >= convInfo.outWidth ||\n                                            Math.floor(dyCol) !== dyCol) {\n                                            continue;\n                                        }\n                                        const pixel = dyBuf.get(batch, dyDepth, dyRow, dyCol, channel);\n                                        dotProd += pixel;\n                                    }\n                                }\n                            }\n                            dx.set(dotProd * avgMultiplier, batch, dxDepth, dxRow, dxCol, channel);\n                        }\n                    }\n                }\n            }\n        }\n        return dx.toTensor();\n    }\n    maxPool3d(x, convInfo) {\n        assertNotComplex(x, 'maxPool3d');\n        return this.pool3d(x, convInfo, 'max').toFloat();\n    }\n    maxPool3dPositions(x, convInfo) {\n        const maxPositions = tf.buffer(convInfo.outShape, 'int32');\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationDepth = convInfo.dilationDepth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n        const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        const padFront = convInfo.padInfo.front;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        const xBuf = this.bufferSync(x);\n        for (let batch = 0; batch < convInfo.batchSize; ++batch) {\n            for (let channel = 0; channel < convInfo.inChannels; ++channel) {\n                for (let yDepth = 0; yDepth < convInfo.outDepth; ++yDepth) {\n                    const xDepthCorner = yDepth * strideDepth - padFront;\n                    let xDepthMin = xDepthCorner;\n                    while (xDepthMin < 0) {\n                        xDepthMin += dilationDepth;\n                    }\n                    const xDepthMax = Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);\n                    for (let yRow = 0; yRow < convInfo.outHeight; ++yRow) {\n                        const xRowCorner = yRow * strideHeight - padTop;\n                        let xRowMin = xRowCorner;\n                        while (xRowMin < 0) {\n                            xRowMin += dilationHeight;\n                        }\n                        const xRowMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);\n                        for (let yCol = 0; yCol < convInfo.outWidth; ++yCol) {\n                            const xColCorner = yCol * strideWidth - padLeft;\n                            let xColMin = xColCorner;\n                            while (xColMin < 0) {\n                                xColMin += dilationWidth;\n                            }\n                            const xColMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner);\n                            // Shader code begins\n                            let maxValue = Number.NEGATIVE_INFINITY;\n                            let maxPosition = -1;\n                            for (let xDepth = xDepthMin; xDepth < xDepthMax; xDepth += dilationDepth) {\n                                const wDepth = xDepth - xDepthCorner;\n                                for (let xRow = xRowMin; xRow < xRowMax; xRow += dilationHeight) {\n                                    const wRow = xRow - xRowCorner;\n                                    for (let xCol = xColMin; xCol < xColMax; xCol += dilationWidth) {\n                                        const wCol = xCol - xColCorner;\n                                        const pixel = xBuf.get(batch, xDepth, xRow, xCol, channel);\n                                        if (pixel >= maxValue) {\n                                            maxValue = pixel;\n                                            maxPosition = wDepth * effectiveFilterHeight *\n                                                effectiveFilterWidth +\n                                                wRow * effectiveFilterHeight + wCol;\n                                        }\n                                    }\n                                }\n                            }\n                            maxPositions.set(maxPosition, batch, yDepth, yRow, yCol, channel);\n                        }\n                    }\n                }\n            }\n        }\n        return maxPositions.toTensor();\n    }\n    maxPool3dBackprop(dy, x, y, convInfo) {\n        assertNotComplex([x, y], 'maxPool3dBackprop');\n        const maxPositions = this.maxPool3dPositions(x, convInfo);\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationDepth = convInfo.dilationDepth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n        const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;\n        const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n        const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n        const dx = tf.buffer(x.shape, 'float32');\n        const maxPosBuf = this.bufferSync(maxPositions);\n        const dyBuf = this.bufferSync(dy);\n        for (let batch = 0; batch < convInfo.batchSize; ++batch) {\n            for (let channel = 0; channel < convInfo.inChannels; ++channel) {\n                for (let dxDepth = 0; dxDepth < convInfo.inDepth; ++dxDepth) {\n                    for (let dxRow = 0; dxRow < convInfo.inHeight; ++dxRow) {\n                        for (let dxCol = 0; dxCol < convInfo.inWidth; ++dxCol) {\n                            // Shader code begins\n                            const dyDepthCorner = dxDepth - padFront;\n                            const dyRowCorner = dxRow - padTop;\n                            const dyColCorner = dxCol - padLeft;\n                            let dotProd = 0;\n                            for (let wDepth = 0; wDepth < effectiveFilterDepth; wDepth += dilationDepth) {\n                                const dyDepth = (dyDepthCorner + wDepth) / strideDepth;\n                                if (dyDepth < 0 || dyDepth >= convInfo.outDepth ||\n                                    Math.floor(dyDepth) !== dyDepth) {\n                                    continue;\n                                }\n                                for (let wRow = 0; wRow < effectiveFilterHeight; wRow += dilationHeight) {\n                                    const dyRow = (dyRowCorner + wRow) / strideHeight;\n                                    if (dyRow < 0 || dyRow >= convInfo.outHeight ||\n                                        Math.floor(dyRow) !== dyRow) {\n                                        continue;\n                                    }\n                                    for (let wCol = 0; wCol < effectiveFilterWidth; wCol += dilationWidth) {\n                                        const dyCol = (dyColCorner + wCol) / strideWidth;\n                                        if (dyCol < 0 || dyCol >= convInfo.outWidth ||\n                                            Math.floor(dyCol) !== dyCol) {\n                                            continue;\n                                        }\n                                        const maxPos = effectiveFilterDepth *\n                                            effectiveFilterHeight * effectiveFilterWidth -\n                                            1 -\n                                            maxPosBuf.get(batch, dyDepth, dyRow, dyCol, channel);\n                                        const curPos = wDepth * effectiveFilterHeight * effectiveFilterWidth +\n                                            wRow * effectiveFilterWidth + wCol;\n                                        const mask = maxPos === curPos ? 1 : 0;\n                                        if (mask === 0) {\n                                            continue;\n                                        }\n                                        const pixel = dyBuf.get(batch, dyDepth, dyRow, dyCol, channel);\n                                        dotProd += pixel * mask;\n                                    }\n                                }\n                            }\n                            dx.set(dotProd, batch, dxDepth, dxRow, dxCol, channel);\n                        }\n                    }\n                }\n            }\n        }\n        return dx.toTensor();\n    }\n    resizeBilinear(x, newHeight, newWidth, alignCorners) {\n        assertNotComplex(x, 'resizeBilinear');\n        const [batch, oldHeight, oldWidth, numChannels] = x.shape;\n        const xValues = this.readSync(x.dataId);\n        const result = new Float32Array(util.sizeFromShape([batch, newHeight, newWidth, numChannels]));\n        const effectiveInputSize = [\n            (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n            (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n        ];\n        const effectiveOutputSize = [\n            (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n            (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n        ];\n        let outputIdx = 0;\n        const effectiveRowSizeRatio = effectiveInputSize[0] / effectiveOutputSize[0];\n        const effectiveColSizeRatio = effectiveInputSize[1] / effectiveOutputSize[1];\n        for (let b = 0; b < batch; b++) {\n            for (let r = 0; r < newHeight; r++) {\n                const sourceFracRow = effectiveRowSizeRatio * r;\n                const sourceRowFloor = Math.floor(sourceFracRow);\n                const rowFrac = sourceFracRow - sourceRowFloor;\n                const sourceRowCeil = Math.min(oldHeight - 1, Math.ceil(sourceFracRow));\n                const topRowOffset = b * x.strides[0] + sourceRowFloor * x.strides[1];\n                const botRowOffset = b * x.strides[0] + sourceRowCeil * x.strides[1];\n                for (let c = 0; c < newWidth; c++) {\n                    const sourceFracCol = effectiveColSizeRatio * c;\n                    const sourceColFloor = Math.floor(sourceFracCol);\n                    const colFrac = sourceFracCol - sourceColFloor;\n                    const sourceColCeil = Math.min(oldWidth - 1, Math.ceil(sourceFracCol));\n                    const topLeftOffest = topRowOffset + sourceColFloor * x.strides[2];\n                    const botLeftOffset = botRowOffset + sourceColFloor * x.strides[2];\n                    const topRightOffset = topRowOffset + sourceColCeil * x.strides[2];\n                    const botRightOffest = botRowOffset + sourceColCeil * x.strides[2];\n                    for (let d = 0; d < numChannels; d++) {\n                        // Begin shader.\n                        // Compute the fractional index of the source.\n                        const topLeft = xValues[topLeftOffest + d];\n                        const bottomLeft = xValues[botLeftOffset + d];\n                        const topRight = xValues[topRightOffset + d];\n                        const bottomRight = xValues[botRightOffest + d];\n                        const top = topLeft + (topRight - topLeft) * colFrac;\n                        const bottom = bottomLeft + (bottomRight - bottomLeft) * colFrac;\n                        const newValue = top + (bottom - top) * rowFrac;\n                        result[outputIdx++] = newValue;\n                    }\n                }\n            }\n        }\n        return tf.tensor(result, [batch, newHeight, newWidth, numChannels]);\n    }\n    resizeBilinearBackprop(dy, x, alignCorners) {\n        assertNotComplex([dy, x], 'resizeBilinearBackprop');\n        const [batch, xHeight, xWidth, depth] = x.shape;\n        const [, yHeight, yWidth] = dy.shape;\n        const output = new Float32Array(batch * xHeight * xWidth * depth);\n        // In the backwards pass, we want to find the pixels that were generated\n        // for each pixel in the input image the forward pass and add the\n        // corresponding coefficient from dy to the gradient (with some\n        // interpolation).\n        const effectiveXSize = [\n            (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,\n            (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth\n        ];\n        const effectiveYSize = [\n            (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,\n            (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth\n        ];\n        const heightScale = effectiveXSize[0] / effectiveYSize[0];\n        const widthScale = effectiveXSize[1] / effectiveYSize[1];\n        // Reference implementation\n        // tslint:disable-next-line:max-line-length\n        // https://github.com/tensorflow/tensorflow/blob/3039375c86a5bbc9610c7725dcaa95d635f87ba2/tensorflow/core/kernels/resize_bilinear_op.cc#L275\n        const dyValues = this.readSync(dy.dataId);\n        let offset = 0;\n        for (let b = 0; b < batch; b++) {\n            const bOffset = b * x.strides[0];\n            for (let r = 0; r < yHeight; r++) {\n                const dxR = r * heightScale;\n                const topDxRIndex = Math.floor(dxR);\n                const bottomDxRIndex = Math.min(Math.ceil(dxR), xHeight - 1);\n                const topDxROffset = bOffset + topDxRIndex * x.strides[1];\n                const bottomDxROffset = bOffset + bottomDxRIndex * x.strides[1];\n                const dxRLerp = dxR - topDxRIndex;\n                const inverseDxRLerp = 1.0 - dxRLerp;\n                for (let c = 0; c < yWidth; c++) {\n                    const dxC = c * widthScale;\n                    const leftDxCIndex = Math.floor(dxC);\n                    const rightDxCIndex = Math.min(Math.ceil(dxC), xWidth - 1);\n                    const dxCLerp = dxC - leftDxCIndex;\n                    const inverseDxCLerp = 1.0 - dxCLerp;\n                    const topLeftRCOffset = topDxROffset + leftDxCIndex * x.strides[2];\n                    const topRightRCOffset = topDxROffset + rightDxCIndex * x.strides[2];\n                    const bottomLeftRCOffset = bottomDxROffset + leftDxCIndex * x.strides[2];\n                    const bottomRightRCOffset = bottomDxROffset + rightDxCIndex * x.strides[2];\n                    const inverseDxRLerpTimesInverseDxCLerp = inverseDxRLerp * inverseDxCLerp;\n                    const inverseDxRLerpTimesDxCLerp = inverseDxRLerp * dxCLerp;\n                    const dxRLerpTimesInverseDxCLerp = dxRLerp * inverseDxCLerp;\n                    const dxRLerpTimesDxCLerp = dxRLerp * dxCLerp;\n                    for (let d = 0; d < depth; d++) {\n                        const dyVal = dyValues[offset++];\n                        output[topLeftRCOffset + d] +=\n                            dyVal * inverseDxRLerpTimesInverseDxCLerp;\n                        output[topRightRCOffset + d] += dyVal * inverseDxRLerpTimesDxCLerp;\n                        output[bottomLeftRCOffset + d] +=\n                            dyVal * dxRLerpTimesInverseDxCLerp;\n                        output[bottomRightRCOffset + d] += dyVal * dxRLerpTimesDxCLerp;\n                    }\n                }\n            }\n        }\n        return tf.tensor4d(output, [batch, xWidth, xHeight, depth], x.dtype);\n    }\n    resizeNearestNeighbor(x, newHeight, newWidth, alignCorners) {\n        assertNotComplex(x, 'resizeNearestNeighbor');\n        const [batch, oldHeight, oldWidth, numChannels] = x.shape;\n        const xValues = this.readSync(x.dataId);\n        const output = new Float32Array(batch * newHeight * newWidth * numChannels);\n        const effectiveInputSize = [\n            (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n            (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n        ];\n        const effectiveOutputSize = [\n            (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n            (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n        ];\n        const effectiveRowSizeRatio = effectiveInputSize[0] / effectiveOutputSize[0];\n        const effectiveColSizeRatio = effectiveInputSize[1] / effectiveOutputSize[1];\n        let outputOffset = 0;\n        for (let b = 0; b < batch; b++) {\n            const batchOffset = b * x.strides[0];\n            for (let r = 0; r < newHeight; r++) {\n                const sourceFracRow = effectiveRowSizeRatio * r;\n                const sourceNearestRow = Math.min(oldHeight - 1, alignCorners ? Math.round(sourceFracRow) :\n                    Math.floor(sourceFracRow));\n                const rowOffset = batchOffset + sourceNearestRow * x.strides[1];\n                for (let c = 0; c < newWidth; c++) {\n                    const sourceFracCol = effectiveColSizeRatio * c;\n                    const sourceNearestCol = Math.min(oldWidth - 1, alignCorners ? Math.round(sourceFracCol) :\n                        Math.floor(sourceFracCol));\n                    const colOffset = rowOffset + sourceNearestCol * x.strides[2];\n                    for (let d = 0; d < numChannels; d++) {\n                        // Begin shader.\n                        // Compute the fractional index of the source.\n                        const newVal = xValues[colOffset + d];\n                        output[outputOffset++] = newVal;\n                    }\n                }\n            }\n        }\n        return tf.tensor(output, [batch, newHeight, newWidth, numChannels], x.dtype);\n    }\n    resizeNearestNeighborBackprop(dy, x, alignCorners) {\n        assertNotComplex([dy, x], 'resizeNearestNeighborBackprop');\n        const [batch, xHeight, xWidth, depth] = x.shape;\n        const [, yHeight, yWidth] = dy.shape;\n        const output = new Float32Array(batch * xHeight * xWidth * depth);\n        const dyValues = this.readSync(dy.dataId);\n        // In the backwards pass, we want to find the pixels that were generated\n        // for each pixel in the input image the forward pass\n        const effectiveXSize = [\n            (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,\n            (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth\n        ];\n        const effectiveYSize = [\n            (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,\n            (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth\n        ];\n        const heightScale = effectiveXSize[0] / effectiveYSize[0];\n        const widthScale = effectiveXSize[1] / effectiveYSize[1];\n        const invHeightScale = 1 / heightScale;\n        const invWidthScale = 1 / widthScale;\n        // This defines the size of the window of values around a particular\n        // index in dy that we want to search for contributions to dx.\n        const winHeight = (Math.ceil(invHeightScale) * 2) + 2;\n        const winWidth = (Math.ceil(invWidthScale) * 2) + 2;\n        // Loop over the output space.\n        for (let b = 0; b < batch; b++) {\n            const batchOffset = b * x.strides[0];\n            for (let r = 0; r < xHeight; r++) {\n                const rowOffset = batchOffset + r * x.strides[1];\n                // Compute bounds for where in dy we will look\n                const startRLerp = Math.floor(r * invHeightScale);\n                const startDyR = Math.floor(startRLerp - (winHeight / 2));\n                for (let c = 0; c < xWidth; c++) {\n                    const colOffset = rowOffset + c * x.strides[2];\n                    // Compute bounds for where in dy we will look\n                    const startCLerp = Math.floor(c * invWidthScale);\n                    const startDyC = Math.floor(startCLerp - (winWidth / 2));\n                    for (let d = 0; d < depth; d++) {\n                        let accum = 0;\n                        // loop over dy\n                        for (let dyRIndex = 0; dyRIndex < winHeight; dyRIndex++) {\n                            const dyR = dyRIndex + startDyR;\n                            // Guard against the window exceeding the bounds of dy\n                            if (dyR < 0 || dyR >= yHeight) {\n                                continue;\n                            }\n                            const dyROffset = batchOffset + dyR * dy.strides[1];\n                            const sourceFracRow = dyR * heightScale;\n                            const sourceNearestRow = Math.min(xHeight - 1, alignCorners ? Math.round(sourceFracRow) :\n                                Math.floor(sourceFracRow));\n                            if (r !== sourceNearestRow) {\n                                continue;\n                            }\n                            for (let dyCIndex = 0; dyCIndex < winWidth; dyCIndex++) {\n                                const dyC = dyCIndex + startDyC;\n                                // Guard against the window exceeding the bounds of dy\n                                if (dyC < 0 || dyC >= yWidth) {\n                                    continue;\n                                }\n                                const dyCOffset = dyROffset + dyC * dy.strides[2];\n                                const sourceFracCol = dyC * widthScale;\n                                const sourceNearestCol = Math.min(xWidth - 1, alignCorners ? Math.round(sourceFracCol) :\n                                    Math.floor(sourceFracCol));\n                                if (c === sourceNearestCol) {\n                                    accum += dyValues[dyCOffset + d];\n                                }\n                            }\n                        }\n                        output[colOffset + d] = accum;\n                    }\n                }\n            }\n        }\n        return tf.tensor4d(output, x.shape, x.dtype);\n    }\n    localResponseNormalization4D(x, depthRadius, bias, alpha, beta) {\n        assertNotComplex(x, 'localResponseNormalization4D');\n        const channels = x.shape[3];\n        const maxD = channels - 1;\n        const xValues = this.readSync(x.dataId);\n        const size = x.size;\n        const result = new Float32Array(size);\n        function sumAcrossChannels(offset) {\n            const currentChannel = offset % channels;\n            let beginSumOffset = offset - currentChannel + Math.max(0, currentChannel - depthRadius);\n            const endSumOffset = offset - currentChannel +\n                Math.min(currentChannel + depthRadius, maxD);\n            let sum = 0.0;\n            for (; beginSumOffset <= endSumOffset; beginSumOffset++) {\n                const z = xValues[beginSumOffset];\n                sum += z * z;\n            }\n            return sum;\n        }\n        for (let offset = 0; offset < size; offset++) {\n            const sum = sumAcrossChannels(offset);\n            const val = xValues[offset] * Math.pow(bias + alpha * sum, -beta);\n            result[offset] = val;\n        }\n        return tf.tensor4d(result, x.shape);\n    }\n    LRNGrad(dy, inputImage, outputImage, depthRadius, bias, alpha, beta) {\n        assertNotComplex(dy, 'LRNGrad');\n        const channels = dy.shape[3];\n        const dyValues = this.readSync(dy.dataId);\n        const inputImageValues = this.readSync(inputImage.dataId);\n        const outputImageValues = this.readSync(outputImage.dataId);\n        const result = new Float32Array(dy.size);\n        const size = dy.size;\n        for (let offset = 0; offset < size; offset++) {\n            const currentChannel = offset % channels;\n            const depthBegin = (offset - currentChannel) + Math.max(0, currentChannel - depthRadius);\n            const depthEnd = (offset - currentChannel) +\n                Math.min(channels, currentChannel + depthRadius + 1);\n            let norm = 0;\n            for (let k = depthBegin; k < depthEnd; k++) {\n                norm += Math.pow(inputImageValues[k], 2);\n            }\n            norm = alpha * norm + bias;\n            for (let k = depthBegin; k < depthEnd; k++) {\n                let dyi = -2 * alpha * beta * inputImageValues[k] *\n                    outputImageValues[offset] / norm;\n                if (offset === k) {\n                    dyi += Math.pow(norm, -beta);\n                }\n                dyi *= dyValues[offset];\n                result[k] += dyi;\n            }\n        }\n        return tf.tensor4d(result, dy.shape);\n    }\n    multinomial(logits, normalized, numSamples, seed) {\n        assertNotComplex(logits, 'multinomial');\n        const probabilities = normalized ? logits : tf.softmax(logits);\n        const batchSize = probabilities.shape[0];\n        const numEvents = probabilities.shape[1];\n        const res = tf.zeros([batchSize, numSamples], 'int32');\n        const resVals = this.readSync(res.dataId);\n        const probVals = this.readSync(probabilities.dataId);\n        for (let b = 0; b < batchSize; ++b) {\n            const offset = b * numEvents;\n            // The cdf won't include the last event. It will be implicit if no other\n            // event happened.\n            const cdf = new Float32Array(numEvents - 1);\n            cdf[0] = probVals[offset];\n            for (let event = 1; event < cdf.length; ++event) {\n                cdf[event] = cdf[event - 1] + probVals[offset + event];\n            }\n            const random = seedrandom.alea(seed.toString());\n            const outOffset = b * numSamples;\n            for (let sampleId = 0; sampleId < numSamples; ++sampleId) {\n                const r = random();\n                // Assume last event happened by default.\n                resVals[outOffset + sampleId] = cdf.length;\n                for (let event = 0; event < cdf.length; event++) {\n                    if (r < cdf[event]) {\n                        resVals[outOffset + sampleId] = event;\n                        break;\n                    }\n                }\n            }\n        }\n        return res;\n    }\n    oneHot(indices, depth, onValue, offValue) {\n        assertNotComplex(indices, 'oneHot');\n        const res = new Float32Array(indices.size * depth);\n        res.fill(offValue);\n        const indicesVal = this.readSync(indices.dataId);\n        for (let event = 0; event < indices.size; ++event) {\n            if (indicesVal[event] >= 0 && indicesVal[event] < depth) {\n                res[event * depth + indicesVal[event]] = onValue;\n            }\n        }\n        return tf.tensor2d(res, [indices.size, depth], 'int32');\n    }\n    nonMaxSuppression(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {\n        assertNotComplex(boxes, 'nonMaxSuppression');\n        const boxesVals = this.readSync(boxes.dataId);\n        const scoresVals = this.readSync(scores.dataId);\n        return nonMaxSuppressionV3Impl(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);\n    }\n    depthToSpace(x, blockSize, dataFormat) {\n        util.assert(dataFormat === 'NHWC', () => `Only NHWC dataFormat supported on CPU for depthToSpace. Got ${dataFormat}`);\n        util.assert(blockSize > 1, () => `blockSize should be > 1 for depthToSpace, but was: ${blockSize}`);\n        const batchSize = x.shape[0];\n        const inputHeight = x.shape[1];\n        const inputWidth = x.shape[2];\n        const inputDepth = x.shape[3];\n        const outputHeight = inputHeight * blockSize;\n        const outputWidth = inputWidth * blockSize;\n        const outputDepth = inputDepth / (blockSize * blockSize);\n        const xValues = this.readSync(x.dataId);\n        const result = new Float32Array(batchSize * outputHeight * outputWidth * outputDepth);\n        let outputIdx = 0;\n        for (let b = 0; b < batchSize; ++b) {\n            for (let h = 0; h < outputHeight; ++h) {\n                const inH = Math.floor(h / blockSize);\n                const offsetH = (h % blockSize);\n                for (let w = 0; w < outputWidth; ++w) {\n                    const inW = Math.floor(w / blockSize);\n                    const offsetW = (w % blockSize);\n                    const offsetD = (offsetH * blockSize + offsetW) * outputDepth;\n                    for (let d = 0; d < outputDepth; ++d) {\n                        const inD = d + offsetD;\n                        const inputIdx = inD + inputDepth * (inW + inputWidth * (inH + inputHeight * b));\n                        result[outputIdx++] = xValues[inputIdx];\n                    }\n                }\n            }\n        }\n        return tf.tensor4d(result, [batchSize, outputHeight, outputWidth, outputDepth]);\n    }\n    broadcastedBinaryOp(a, b, dtype, op) {\n        const newShape = backend_util.assertAndGetBroadcastShape(a.shape, b.shape);\n        const result = tf.buffer(newShape, dtype);\n        const aVals = this.readSync(a.dataId);\n        const bVals = this.readSync(b.dataId);\n        const aBroadcastDims = backend_util.getBroadcastDims(a.shape, newShape);\n        const bBroadcastDims = backend_util.getBroadcastDims(b.shape, newShape);\n        const resVals = result.values;\n        if (aBroadcastDims.length + bBroadcastDims.length === 0) {\n            for (let i = 0; i < resVals.length; ++i) {\n                resVals[i] = op(aVals[i % aVals.length], bVals[i % bVals.length]);\n            }\n        }\n        else {\n            const aBuf = this.bufferSync(a);\n            const bBuf = this.bufferSync(b);\n            for (let i = 0; i < resVals.length; ++i) {\n                const loc = result.indexToLoc(i);\n                const aLoc = loc.slice(-a.rank);\n                aBroadcastDims.forEach(d => aLoc[d] = 0);\n                const aIndex = aBuf.locToIndex(aLoc);\n                const bLoc = loc.slice(-b.rank);\n                bBroadcastDims.forEach(d => bLoc[d] = 0);\n                const bIndex = bBuf.locToIndex(bLoc);\n                resVals[i] = op(aVals[aIndex], bVals[bIndex]);\n            }\n        }\n        return result.toTensor();\n    }\n    split(x, sizeSplits, axis) {\n        return split(x, sizeSplits, axis);\n    }\n    dispose() { }\n    floatPrecision() {\n        return 32;\n    }\n    /** Returns the smallest representable number.  */\n    epsilon() {\n        return super.epsilon();\n    }\n    cropAndResize(images, boxes, boxIndex, cropSize, method, extrapolationValue) {\n        const [batch, imageHeight, imageWidth, numChannels] = images.shape;\n        const numBoxes = boxes.shape[0];\n        const [cropHeight, cropWidth] = cropSize;\n        const output = tf.buffer([numBoxes, cropHeight, cropWidth, numChannels], 'float32');\n        const boxVals = this.readSync(boxes.dataId);\n        const boxIndVals = this.readSync(boxIndex.dataId);\n        const imageVals = this.readSync(images.dataId);\n        const inStride = images.strides; // to calculate flat indexes into image\n        const outStride = output.strides; // to calculate flat indexes into output\n        // Reference implementation\n        // tslint:disable-next-line:max-line-length\n        // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/crop_and_resize_op.cc\n        for (let b = 0; b < numBoxes; b++) {\n            const startInd = b * 4;\n            const y1 = boxVals[startInd];\n            const x1 = boxVals[startInd + 1];\n            const y2 = boxVals[startInd + 2];\n            const x2 = boxVals[startInd + 3];\n            const bInd = boxIndVals[b];\n            if (bInd >= batch) {\n                continue;\n            }\n            const heightScale = (cropHeight > 1) ?\n                (y2 - y1) * (imageHeight - 1) / (cropHeight - 1) :\n                0;\n            const widthScale = (cropWidth > 1) ? (x2 - x1) * (imageWidth - 1) / (cropWidth - 1) : 0;\n            for (let y = 0; y < cropHeight; y++) {\n                const yInd = (cropHeight > 1) ?\n                    y1 * (imageHeight - 1) + y * (heightScale) :\n                    0.5 * (y1 + y2) * (imageHeight - 1);\n                if (yInd < 0 || yInd > imageHeight - 1) {\n                    for (let x = 0; x < cropWidth; x++) {\n                        for (let c = 0; c < numChannels; c++) {\n                            const ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n                            output.values[ind] = extrapolationValue;\n                        }\n                    }\n                    continue;\n                }\n                if (method === 'bilinear') {\n                    const topInd = Math.floor(yInd);\n                    const bottomInd = Math.ceil(yInd);\n                    const yLerp = yInd - topInd;\n                    for (let x = 0; x < cropWidth; x++) {\n                        const xInd = (cropWidth > 1) ?\n                            x1 * (imageWidth - 1) + x * widthScale :\n                            0.5 * (x1 + x2) * (imageWidth - 1);\n                        if (xInd < 0 || xInd > imageWidth - 1) {\n                            for (let c = 0; c < numChannels; c++) {\n                                const ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n                                output.values[ind] = extrapolationValue;\n                            }\n                            continue;\n                        }\n                        const leftInd = Math.floor(xInd);\n                        const rightInd = Math.ceil(xInd);\n                        const xLerp = xInd - leftInd;\n                        for (let c = 0; c < numChannels; c++) {\n                            let ind = c + leftInd * inStride[2] + topInd * inStride[1] +\n                                bInd * inStride[0];\n                            const topLeft = imageVals[ind];\n                            ind = c + rightInd * inStride[2] + topInd * inStride[1] +\n                                bInd * inStride[0];\n                            const topRight = imageVals[ind];\n                            ind = c + leftInd * inStride[2] + bottomInd * inStride[1] +\n                                bInd * inStride[0];\n                            const bottomLeft = imageVals[ind];\n                            ind = c + rightInd * inStride[2] + bottomInd * inStride[1] +\n                                bInd * inStride[0];\n                            const bottomRight = imageVals[ind];\n                            const top = topLeft + (topRight - topLeft) * xLerp;\n                            const bottom = bottomLeft + (bottomRight - bottomLeft) * xLerp;\n                            ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n                            output.values[ind] = top + ((bottom - top) * yLerp);\n                        }\n                    }\n                }\n                else { // method == \"nearest\"\n                    for (let x = 0; x < cropWidth; ++x) {\n                        const xInd = (cropWidth > 1) ?\n                            x1 * (imageWidth - 1) + x * widthScale :\n                            0.5 * (x1 + x2) * (imageWidth - 1);\n                        if (xInd < 0 || xInd > imageWidth - 1) {\n                            for (let c = 0; c < numChannels; c++) {\n                                const ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n                                output.values[ind] = extrapolationValue;\n                            }\n                            continue;\n                        }\n                        const closestX = Math.round(xInd);\n                        const closestY = Math.round(yInd);\n                        for (let c = 0; c < numChannels; c++) {\n                            const inInd = c + closestX * inStride[2] +\n                                closestY * inStride[1] + bInd * inStride[0];\n                            const outInd = c + x * outStride[2] + y * outStride[1] + b * outStride[0];\n                            output.values[outInd] = imageVals[inInd];\n                        }\n                    }\n                }\n            }\n        }\n        return output.toTensor();\n    }\n    sparseToDense(sparseIndices, sparseValues, outputShape, defaultValue) {\n        const { sliceRank, numUpdates, sliceSize, strides, outputSize } = backend_util.calculateShapes(sparseValues, sparseIndices, outputShape);\n        const sumDupeIndices = false;\n        return this.scatter(sparseIndices, sparseValues, outputShape, outputSize, sliceSize, numUpdates, sliceRank, strides, defaultValue, sumDupeIndices);\n    }\n    gatherND(x, indices) {\n        const indicesShape = indices.shape;\n        const sliceRank = indicesShape[indicesShape.length - 1];\n        const [resultShape, numSlices, sliceSize, strides] = backend_util.prepareAndValidate(x, indices);\n        if (numSlices === 0) {\n            return tf.tensor([], resultShape, x.dtype);\n        }\n        const buffer = new TensorBuffer([numSlices, sliceSize], x.dtype);\n        const indicesData = this.readSync(indices.dataId);\n        const xData = this.readSync(x.dataId);\n        for (let i = 0; i < numSlices; i++) {\n            const index = [];\n            let flattenIndex = 0;\n            for (let j = 0; j < sliceRank; j++) {\n                const dim = indicesData[i * sliceRank + j];\n                flattenIndex += dim * strides[j];\n                index.push(dim);\n            }\n            if (flattenIndex < 0 || flattenIndex >= x.size / sliceSize) {\n                throw new Error(`Invalid indices: ${index} does not index into ${x.shape}`);\n            }\n            for (let k = 0; k < sliceSize; k++) {\n                buffer.values[i * sliceSize + k] = xData[flattenIndex * sliceSize + k];\n            }\n        }\n        return buffer.toTensor().reshape(resultShape);\n    }\n    scatterND(indices, updates, shape) {\n        const { sliceRank, numUpdates, sliceSize, strides, outputSize } = backend_util.calculateShapes(updates, indices, shape);\n        const defaultValue = tf.scalar(0);\n        const sumDupeIndices = true;\n        return this.scatter(indices, updates, shape, outputSize, sliceSize, numUpdates, sliceRank, strides, defaultValue, sumDupeIndices);\n    }\n    onesLike(x) {\n        if (x.dtype === 'string') {\n            throw new Error('onesLike is not supported for string tensors');\n        }\n        else {\n            // TODO(lina128): Use fill kernel directly once this kernel is\n            // modularized.\n            return tf.fill(x.shape, 1, x.dtype);\n        }\n    }\n    zerosLike(x) {\n        const values = util.getArrayFromDType(x.dtype, util.sizeFromShape(x.shape));\n        return this.makeOutput(values, x.shape, x.dtype);\n    }\n    linspace(start, stop, num) {\n        return backend_util.linspaceImpl(start, stop, num);\n    }\n    scatter(indices, updates, shape, outputSize, sliceSize, numUpdates, sliceRank, strides, defaultValue, sumDupeIndices) {\n        const flattenShape = [outputSize / sliceSize, sliceSize];\n        const indicesData = this.readSync(indices.dataId);\n        const updatesData = this.readSync(updates.dataId);\n        if (outputSize === 0) {\n            return tf.tensor([], shape, updates.dtype);\n        }\n        const buffer = new TensorBuffer(flattenShape, updates.dtype);\n        buffer.values.fill(this.readSync(defaultValue.dataId)[0]);\n        for (let i = 0; i < numUpdates; i++) {\n            const index = [];\n            let flattenIndex = 0;\n            for (let j = 0; j < sliceRank; j++) {\n                const dim = indicesData[i * sliceRank + j];\n                index.push(dim);\n                flattenIndex += dim * strides[j];\n            }\n            if (flattenIndex < 0 || flattenIndex >= outputSize / sliceSize) {\n                throw new Error(`Invalid indices: ${index} does not index into ${shape}`);\n            }\n            for (let k = 0; k < sliceSize; k++) {\n                if (sumDupeIndices) {\n                    buffer.values[flattenIndex * sliceSize + k] +=\n                        updatesData[i * sliceSize + k];\n                }\n                else {\n                    buffer.values[flattenIndex * sliceSize + k] = updates.rank === 0 ?\n                        updatesData[0] :\n                        updatesData[i * sliceSize + k];\n                }\n            }\n        }\n        return buffer.toTensor().reshape(shape);\n    }\n}\n//# sourceMappingURL=backend_cpu.js.map"]},"metadata":{},"sourceType":"module"}